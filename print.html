<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>呂學洲</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="各種紀錄和連結">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 自我介紹</a></li><li class="chapter-item expanded "><a href="projects/index.html"><strong aria-hidden="true">2.</strong> 開源專案</a></li><li class="chapter-item expanded "><a href="feedback/index.html"><strong aria-hidden="true">3.</strong> 讀書心得（照字母排序）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feedback/designing-data-intensive-applications/introduction.html"><strong aria-hidden="true">3.1.</strong> Designing Data-intensive Applications</a></li><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/introduction.html"><strong aria-hidden="true">3.2.</strong> Distributed Systems with Node.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/protocol.html"><strong aria-hidden="true">3.2.1.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/sla-and-load-testing.html"><strong aria-hidden="true">3.2.2.</strong> SLA and Load Testing</a></li><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/observability.html"><strong aria-hidden="true">3.2.3.</strong> Observability</a></li><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/container.html"><strong aria-hidden="true">3.2.4.</strong> Container</a></li><li class="chapter-item expanded "><a href="feedback/distributed-systems-with-node.js/container-orchestration-and-misc.html"><strong aria-hidden="true">3.2.5.</strong> Container Orchestration and Misc.</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="essay/index.html"><strong aria-hidden="true">4.</strong> 隨筆</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="essay/made-container.html"><strong aria-hidden="true">4.1.</strong> 如何製作 Docker Container</a></li><li class="chapter-item expanded "><a href="essay/node.js-best-practice.html"><strong aria-hidden="true">4.2.</strong> Node.js 最佳實作</a></li><li class="chapter-item expanded "><a href="essay/node.js-error.html"><strong aria-hidden="true">4.3.</strong> Node.js 的錯誤有哪些</a></li><li class="chapter-item expanded "><a href="essay/pki-checklist.html"><strong aria-hidden="true">4.4.</strong> 建置 PKI 注意事項</a></li><li class="chapter-item expanded "><a href="essay/questionnaire-principal.html"><strong aria-hidden="true">4.5.</strong> 問卷設計指南</a></li><li class="chapter-item expanded "><a href="essay/retry-strategy.html"><strong aria-hidden="true">4.6.</strong> Retry 的策略</a></li><li class="chapter-item expanded "><a href="essay/url-structure.html"><strong aria-hidden="true">4.7.</strong> URL 長什麼樣子</a></li><li class="chapter-item expanded "><a href="essay/vault/index.html"><strong aria-hidden="true">4.8.</strong> Vault</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="essay/vault/introduction.html"><strong aria-hidden="true">4.8.1.</strong> 介紹</a></li><li class="chapter-item expanded "><a href="essay/vault/implementation.html"><strong aria-hidden="true">4.8.2.</strong> 實作</a></li><li class="chapter-item expanded "><a href="essay/vault/engine-pki.html"><strong aria-hidden="true">4.8.3.</strong> PKI</a></li><li class="chapter-item expanded "><a href="essay/vault/engine-transit.html"><strong aria-hidden="true">4.8.4.</strong> Transit</a></li></ol></li><li class="chapter-item expanded "><a href="essay/web-security/index.html"><strong aria-hidden="true">4.9.</strong> 網路安全</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="essay/web-security/cross-origin-resources-sharing.html"><strong aria-hidden="true">4.9.1.</strong> CORS</a></li><li class="chapter-item expanded "><a href="essay/web-security/mixed-content.html"><strong aria-hidden="true">4.9.2.</strong> Mixed Content</a></li><li class="chapter-item expanded "><a href="essay/web-security/owasp-api-top10.html"><strong aria-hidden="true">4.9.3.</strong> OWASP API Top 10</a></li><li class="chapter-item expanded "><a href="essay/web-security/owasp-authentication-best-practice.html"><strong aria-hidden="true">4.9.4.</strong> OWASP 驗證機制最佳指南</a></li><li class="chapter-item expanded "><a href="essay/web-security/owasp-mobile-risk-top10.html"><strong aria-hidden="true">4.9.5.</strong> OWASP 行動裝置風險</a></li></ol></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">呂學洲</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/evan361425/evan361425.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>HI 我叫呂學洲，我在 104 人力銀行工作，歡迎發 PR 做任何修改。</p>
<p>我有一些<a href="projects/index.html">開源專案</a>，還有一些<a href="feedback/index.html">讀書心得</a>跟<a href="essay/index.html">隨筆</a>。</p>
<p>這裡方便我做整理，不像 GitBook 有不好用的編輯器或 HackMD 不方便管理的介面。</p>
<div style="break-before: page; page-break-before: always;"></div><p>以下是我建立的開源專案</p>
<h2 id="flutter"><a class="header" href="#flutter">Flutter</a></h2>
<ul>
<li><a href="https://github.com/evan361425/flutter-pos-system">POS 系統</a></li>
<li><a href="https://github.com/evan361425/flutter-simple-tip">Flutter 提示工具</a></li>
</ul>
<h2 id="nodejs"><a class="header" href="#nodejs">Node.js</a></h2>
<ul>
<li><a href="https://github.com/evan361425/ts-jose">用 TypeScript 包裝 JOSE</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>這裡作為我的讀書紀錄，讀完但是覺得不需要寫心得就不列在這了。</p>
<table><thead><tr><th>書名</th><th>作者</th><th>狀態</th><th>出版日期</th></tr></thead><tbody>
<tr><td>Modern-CPU-Design</td><td>-</td><td><a href="feedback/index.html#%E6%83%B3%E8%AE%80">想讀</a></td><td>-</td></tr>
<tr><td>Blue-Green-Test</td><td>-</td><td><a href="feedback/index.html#%E6%83%B3%E8%AE%80">想讀</a></td><td>-</td></tr>
<tr><td>Implementation-Patterns</td><td>Kent Beck</td><td><a href="feedback/index.html#%E8%AE%80%E5%AE%8C">讀完</a></td><td>2007-10</td></tr>
<tr><td><a href="feedback/distributed-systems-with-node.js/introduction.html">Distributed-Systems-with-Node.js</a></td><td>Thomas Hunter</td><td><a href="feedback/index.html#%E5%AE%8C%E6%88%90">完成</a></td><td>2020-11</td></tr>
<tr><td><a href="feedback/designing-data-intensive-applications/introduction.html">Designing-Data-intensive-Applications</a></td><td>Martin Kleppmann</td><td><a href="feedback/index.html#%E5%AF%AB%E4%BD%9C%E4%B8%AD">寫作中</a></td><td>2017-03</td></tr>
</tbody></table>
<h2 id="依狀態區分"><a class="header" href="#依狀態區分">依狀態區分</a></h2>
<h3 id="想讀"><a class="header" href="#想讀">想讀</a></h3>
<p>嗯。</p>
<h3 id="讀完"><a class="header" href="#讀完">讀完</a></h3>
<p>讀完書，但是還沒開始寫心得。</p>
<ul>
<li>Implementation-Patterns</li>
</ul>
<h3 id="寫作中"><a class="header" href="#寫作中">寫作中</a></h3>
<p>讀完書，開始寫作。</p>
<ul>
<li><a href="feedback/designing-data-intensive-applications/introduction.html">Designing-Data-intensive-Applications</a></li>
</ul>
<h3 id="完成"><a class="header" href="#完成">完成</a></h3>
<p>讀完且寫完心得。</p>
<ul>
<li><a href="feedback/distributed-systems-with-node.js/introduction.html">Distributed-Systems-with-Node.js</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>一個應用程式需要滿足許多需求才能提供特定服務。</p>
<ul>
<li>功能性需求，例如：允許存取資料、搜尋等等。</li>
<li>非功能性需求，例如：
<ul>
<li>安全性（security）</li>
<li>可靠性（reliability）</li>
<li>順從性（compliance）</li>
<li>可延展性（compatibility）</li>
<li>相容性（scalability）</li>
<li>可維護性（maintainability）</li>
</ul>
</li>
</ul>
<h2 id="可靠性"><a class="header" href="#可靠性">可靠性</a></h2>
<p>當服務發生狀況時，仍然能正確運行。狀況可能為</p>
<ul>
<li>硬體，通常是無相關性且隨機的</li>
<li>軟體，通常是性統性的且難以解決</li>
<li>人為</li>
</ul>
<p>容錯能力（Fault-tolerance）代表他能接受特定狀況的發生，並讓使用者不會受此影響。</p>
<h2 id="可延展性"><a class="header" href="#可延展性">可延展性</a></h2>
<p>可延展性代表即使流量增加，表現仍是正常的。在討論延展性前，需定義流量（load）和表現能力（performance quantitatively）。以 Twitter 的個人首頁為例，利用回應時間的百分位數（percentiles）代表表現能力。即使流量增加，回應時間的百分位數仍低於特定水平。</p>
<p>在一個可擴充的系統，我們可以增加機器的量（processing capacity）來維持可靠的表現能力。</p>
<h2 id="可維護性"><a class="header" href="#可維護性">可維護性</a></h2>
<p>可維護性有很多面向，基本上來說，就是為了讓工程師和運維工程師準時。讓系統保持抽象化（把維度提高）可以降低系統的複雜性，並且讓其更容易修改和適應新的功能。</p>
<p>好的操作性（operability）代表能觀察到系統內部運作狀態和健康檢查，並且擁有高效的方式去管理。</p>
<h2 id="結論"><a class="header" href="#結論">結論</a></h2>
<p>通常來說不會有一個辦法可以簡單且完整的讓應用程式可靠、好延展和維護。然而，都會有某種模式或工具幫助我們一個一個解決這些問題。</p>
<p>以下這張圖代表一般應用程式的框架：</p>
<p><img src="https://i.imgur.com/4uYcSaB.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><table><thead><tr><th>參考書籍</th><th>使用 Repo</th></tr></thead><tbody>
<tr><td><a href="https://www.booktopia.com.au/distributed-systems-with-node-js-thomas-hunter-ii/ebook/9781492077244.html">Distributed-Systems-with-Node.js</a></td><td><a href="https://github.com/evan361425/distributed-node">evan361425/distributed-node</a></td></tr>
</tbody></table>
<p><img src="https://i.imgur.com/UeShSDB.png" alt="" /></p>
<h2 id="說明"><a class="header" href="#說明">說明</a></h2>
<p>傳統上，應用程式皆為同一包程式碼中，這時會造成什麼問題？</p>
<ol>
<li>修改程式碼時，可能無意間破壞掉其中各個關係的協作，Debug 代價很高</li>
<li>每次交付、部署都會花很長時間</li>
<li>新進員工，或想進入這個專案的門檻（理解專案的時間）提高</li>
</ol>
<p>整體來說，這樣的做法成本太高了。</p>
<hr />
<p>分散式系統，即是把一個大型應用程式，拆成幾個小的服務。
這時仍會遇到傳統做法不會遇到的問題：</p>
<ol>
<li>風險提高，因服務彼此之間有連結，若 A 服務壞了，B 服務也會壞掉。多一台機器，就多一份機器壞掉的風險</li>
<li>增加溝通需要的時間、風險和流量</li>
<li>本來同一個應用程式，可以共用一份設定檔、程式碼和機敏資料，若服務變多了，該怎麼同步這些共用的檔案</li>
<li>要怎麼知道特定 Request 為什麼會回 500，哪台壞了？</li>
<li>限制特定服務僅能在服務間溝通，而不能對外（VPC）</li>
</ol>
<hr />
<p>之後會使用的範例架構若無說明則為：</p>
<pre><code>  ┌───────────────────────────┐
  │         Application       │
  │  ┌───────┐  ┌──────────┐  │  ┌────┐
  │  │web-api◄──►recipe-api◄──┼──►User│
  │  └───────┘  └──────────┘  │  └────┘
  │                           │
  └───────────────────────────┘
</code></pre>
<p>講解順序：</p>
<p>（後面的「問題 x」代表嘗試解決的問題）</p>
<ol>
<li><a href="feedback/distributed-systems-with-node.js/protocol">Protocol</a> - 不同的服務間，該用什麼方式溝通，問題 2</li>
<li><a href="feedback/distributed-systems-with-node.js/sla-and-load-testing">SLA and Load Testing</a> - 如何證明效率在接受範圍內，問題 2</li>
<li><a href="feedback/distributed-systems-with-node.js/observability">Observability</a> - Log、Metric 和 Tracing，問題 4</li>
<li><a href="feedback/distributed-systems-with-node.js/container">Container</a> - 服務變多了，部署上該使用什麼方式，問題 1</li>
<li><a href="feedback/distributed-systems-with-node.js/container-orchestration-and-misc">Container Orchestration and Misc.</a> - 容器調度工具，問題 1~5</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>分散式系統中，很重要的一塊是「不同的服務間，彼此的溝通方式是什麼？」
比起撰寫完整又清楚的 API 文件，有沒有什麼好方法可以讓服務和服務之間同步 API？</p>
</blockquote>
<p>以下討論皆假設：溝通是透過網路，且以 HTTP 協定為基礎。</p>
<h2 id="osi-open-systems-interconnection"><a class="header" href="#osi-open-systems-interconnection">OSI (Open Systems Interconnection)</a></h2>
<ul>
<li>應用層（Application Layer）</li>
<li>表達層（Presentation Layer）</li>
<li>會議層（Session Layer）</li>
<li>傳輸層（Transport Layer）</li>
<li>網路層（Network Layer）</li>
<li>資料連結層（Data Link Layer）</li>
<li>實體層（Physical Layer）</li>
</ul>
<pre><code class="language-text">┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                             Data Frame                                                │
├─────────────────┬─────────┬───────────┬───────────┬───────────────────────────────────────┬───────────┤
│        DLH      │    H3   │     H4    │     H5    │      H6      │ H7 │       DATA        │    DLT    │
│                 │         │           │           │         ┌────┐         ┌────┐         │           │
│                 │         │           │           │ chunk 1 │Sync│ chunk 2 │Sync│ chunk N │           │
│                 │         │           │           └─────────┘    └─────────┘    └─────────┤           │
│                 │         │           │                                                   │           │
├─────────────────┼─────────┼───────────┼───────────┬──────────────┬────────────────────────┼───────────┤
│    Data Link    │ Network │ Transport │  Session  │ Presentation │       Application      │ Data Link │
├─────────────────┼─────────┼───────────┼───────────┼──────────────┼────────────────────────┼───────────┤
│                 │         │           │ Uncurrent │  Uncurrent   │                        │           │
├─────────────────┼─────────┼───────────┼───────────┴──────────────┴────────────────────────┼───────────┤
│ Error Detection │    IP   │    TCP    │                        HTTP                       │   Wi─Fi   │
│ Error Tolerance │         │    UDP    │───────────┬──────────────┬────────────────────────┤  Ethernet │
│                 │         │           │   Socket  │     ASCII    │                        │           │
│                 │         │           │           │     UTF─8    │                        │           │
│                 │         │           ├───────────┼──────────────┘                        │           │
│                 │         │           │           │                   FTP                 │           │
│                 │         │           └───────────┴──────────────┬────────────────────────┴───────────┤
│                 │         │                 TLS                  │                                    │
└─────────────────┴─────────┴──────────────────────────────────────┴────────────────────────────────────┘
</code></pre>
<h2 id="http"><a class="header" href="#http">HTTP</a></h2>
<pre><code class="language-text">POST / HTTP/1.1
Host: www.example.com
Content-Type: application/json
Content-Length: 15

{&quot;name&quot;:&quot;evan.lu&quot;}
</code></pre>
<p>空行後的下一行即為代表本次<em>請求</em>的 <strong>body</strong>，範例中的 <strong>body</strong> 是常見的 <code>JSON</code> 格式。</p>
<p>由此，可以想像 <code>JSON</code> 格式是在<em>應用層</em>之上的<strong>第八層</strong>。</p>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>單純透過 <code>JSON</code> 傳遞有什麼缺點？</p>
<ol>
<li>正確的資料格式應該要長什麼樣子？</li>
<li>使用者需要閱讀相關文件，有辦法讓機器自動處理嗎？</li>
</ol>
<p>為了解決上述問題，就會有其他 protocol 需要被引入。</p>
<p>不過除了用其他協定，也有一些方式可以舒緩（降低）上述發生的問題，如：</p>
<ul>
<li><a href="https://jsonapi.org/format/">JSON API</a></li>
<li><a href="http://json-schema.org/specification.html">JSON Schema</a></li>
<li><a href="https://swagger.io/specification/">OpenAPI (Swagger)</a></li>
</ul>
<blockquote>
<p>上述僅是制定一些規範，讓使用者在閱讀相關 API 文件時，能較快進入狀況。</p>
</blockquote>
<h3 id="graphql"><a class="header" href="#graphql">GraphQL</a></h3>
<p>GraphQL 讓<em>使用者</em>在跟<em>服務</em>要取資料的時候能指定特定資料，這有幾個好處：</p>
<ul>
<li>可以拿到最準確的資料，減少網路傳輸</li>
<li>把多種服務的資料在一次請求中要齊</li>
</ul>
<p>這也讓 GraphQL 通常成為 <em>facade services</em>，也就是在眾多服務中的首個接觸點，並作為對外溝通的唯一渠道。</p>
<blockquote>
<p>GraphQL 並不限定在要 HTTP 上執行，也能執行如 TCP 等協定之上。</p>
</blockquote>
<blockquote>
<p>雖然請求時送出的是類似 Query 的語法，但 Response 並無指定，只要能代表其階層式的結果就行，如 <code>JSON</code>。</p>
</blockquote>
<h4 id="規範"><a class="header" href="#規範">規範</a></h4>
<pre><code class="language-graphql=">type RecipeRoot {
  recipe(id: ID): Recipe
  pid: Int
}
type Recipe {
  id: ID!
  name: String!
  steps: String
  ingredients: [Ingredient]!
}
type Ingredient {
  id: ID!
  name: String!
  quantity: String
}
</code></pre>
<p>這份檔案是可以對外公開的，幫助使用者依此撰寫程式，類似上述提到的 OpenAPI。</p>
<h4 id="請求"><a class="header" href="#請求">請求</a></h4>
<p>這時，我們可以依照上述的規範送出請求：</p>
<pre><code>{
  pid
}
</code></pre>
<pre><code class="language-json=">{
  &quot;data&quot;: {
    &quot;pid&quot;: 9372
  }
}
</code></pre>
<pre><code>{
  recipe(id: 42) {
    name
    ingredients {
      name
      quantity
    }
  }
}
</code></pre>
<pre><code class="language-json=">{
  &quot;data&quot;: {
    &quot;recipe&quot;: {
      &quot;name&quot;: &quot;Chicken Tikka Masala&quot;,
      &quot;ingredients&quot;: [
        { &quot;name&quot;: &quot;Chicken&quot;, &quot;quantity&quot;: &quot;1 lb&quot; },
        { &quot;name&quot;: &quot;Sauce&quot;, &quot;quantity&quot;: &quot;2 cups&quot; }
      ]
    }
  }
}
</code></pre>
<hr />
<h4 id="code-demo"><a class="header" href="#code-demo">Code Demo</a></h4>
<p>下列則是以 Node.js 為基礎的範例：</p>
<ul>
<li><a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-graphql.ts">web-api 原始碼</a></li>
</ul>
<pre><code class="language-typescript=">// 僅展示請求的範例，這裡的 `kitchenSink` 是自定義名稱，方便 debug 用的
const query = `query kitchenSink ($id:ID) {
  recipe(id: $id) {
    id name
    ingredients {
      name quantity
    }
  }
  pid
}`;
const variables = { id: '42' };

return got(`http://${TARGET}/graphql`, {
  method: 'POST',
  json: { query, variables },
})
</code></pre>
<ul>
<li><a href="https://github.com/evan361425/distributed-node/blob/master/src/recipe-api/producer-graphql.ts">recipe-api 原始碼</a></li>
</ul>
<pre><code class="language-typescript=">import { GraphQLID, GraphQLInt, GraphQLObjectType, GraphQLSchema } from 'graphql';

// 僅展示 RecipeRoot 的建置方式
const recipeRoot = new GraphQLObjectType({
  name: 'RecipeRoot',
  fields: {
    pid: {
      type: GraphQLInt,
      resolve: resolvers.RecipeRoot.pid,
    },
    recipe: {
      type: recipeQuery,
      args: { id: { type: GraphQLID } },
      resolve: resolvers.RecipeRoot.recipe,
    },
  },
});
return new GraphQLSchema({ query: rootQuery });
</code></pre>
<h4 id="live-demo"><a class="header" href="#live-demo">Live Demo</a></h4>
<p>http://localhost:4000/graphql</p>
<h3 id="grpc"><a class="header" href="#grpc">gRPC</a></h3>
<p>像是 REST 或 GraphQL 都是建立在資料之上，而透過 CRUD 的方式去執行行為，這裡就可以注意到其限制：</p>
<blockquote>
<p>大量的名詞，而僅有少量的動詞</p>
</blockquote>
<p>舉例：
若有一個 API endpoint 是用來建立發票，今欲新增一附帶條件：<strong>是否同時寄送信箱通知</strong>。
有什麼樣的方式？</p>
<ul>
<li>再建立一個 endpoint 專門做這件事： 過多 API，難管理和理解</li>
<li>在該 endpoint 新增變數：<code>need_send_email</code>： 讓該 endpoint 越來越複雜</li>
</ul>
<p><code>Remote Procedure Call</code> 就是來解決此事的！</p>
<blockquote>
<p>gRPC 為 Google 建立的 RPC 標準</p>
</blockquote>
<p>gRPC 預設即非使用 JSON 格式進行資訊的傳遞，而是以 <code>Protocol Buffers</code>（ProtoBufs）的方式進行傳遞。</p>
<p>有幾個條件：</p>
<ul>
<li>所有格式皆須預先設定好，副檔名為 <code>.proto</code>，且需要讓 client 擁有。</li>
<li>各值需給定順序，且之後不建議修改。</li>
<li>數字有多型別：<code>int32</code>，<code>int64</code>，<code>float</code>，<code>double</code> 等等。</li>
</ul>
<p>這些條件有幾個好處：</p>
<ul>
<li>效能、體積的最優化，binary serialize/deserialize</li>
</ul>
<pre><code class="language-text">{&quot;id&quot;:42} v.s. 42
</code></pre>
<ul>
<li>向後相容</li>
</ul>
<pre><code class="language-text">v1 需要 arg1 arg2
v2 需要 arg1 arg2 arg3
若 client 僅拿到 v1 的 proto，程式上會自動忽略 arg2 後的參數
</code></pre>
<hr />
<h4 id="code-demo-1"><a class="header" href="#code-demo-1">Code Demo</a></h4>
<ul>
<li>gRPC proto</li>
</ul>
<pre><code class="language-proto=">syntax = &quot;proto3&quot;;
package recipe;
service RecipeService {
  rpc GetRecipe(RecipeRequest) returns (Recipe) {}
  rpc GetMetaData(Empty) returns (Meta) {}
}
message Recipe {
  int32 id = 1;
  string name = 2;
  string steps = 3;
  repeated Ingredient ingredients = 4;
}
message Ingredient {
  int32 id = 1;
  string name = 2;
  string quantity = 3;
}
message RecipeRequest {
  int32 id = 1;
}
message Meta {
  int32 pid = 2;
}
message Empty {}
</code></pre>
<ul>
<li>建立 service，<a href="https://github.com/evan361425/distributed-node/blob/master/src/recipe-api/producer-grpc.ts">原始碼</a></li>
</ul>
<pre><code class="language-javascript=">import { loadPackageDefinition, Server } from '@grpc/grpc-js';
import { loadSync } from '@grpc/proto-loader';

// 讀取 proto 檔
const def = loadSync(__dirname + '/grpc.proto');
const proto = loadPackageDefinition(def);

// 建立處理邏輯
// handlers = ...;
const server = new Server();
server.addService(
  proto.recipe.RecipeService.service,
  handlers,
);

// 建立對外連線
// credentials = ...; for https
const cb = () =&gt; server.start();
server.bindAsync(`${HOST}:${PORT}`, credentials, cb);

// 建立 handlers
const handlers = {
  GetMetaData: (_call, cb) =&gt; {
    cb(null, { // error = null
      pid: process.pid,
    });
  },
  GetRecipe: (call, cb) =&gt; ({}) // if (call.request.id === 42)
}
</code></pre>
<ul>
<li>建立 client，<a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-grpc.ts">原始碼</a></li>
</ul>
<pre><code class="language-javascript=">import { loadPackageDefinition } from '@grpc/grpc-js';
import { loadSync } from '@grpc/proto-loader';

// 讀取 proto 檔
const def = loadSync(__dirname + '/grpc.proto');
const proto = loadPackageDefinition(def);

// credentials = ...; for https
const client = new proto.recipe.RecipeService(TARGET, credentials);

client.getMetaData({}, cb);
client.getRecipe({ id: 42 }, cb);

</code></pre>
<h4 id="live-demo-1"><a class="header" href="#live-demo-1">Live Demo</a></h4>
<p>http://localhost:3001</p>
<hr />
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>除了 gRPC 還有什麼類似的東西？</p>
<p><strong>ProtoBufs</strong></p>
<p><em>MessagePack</em></p>
<p>雖然同為 binary representation of hierarchical object data，但</p>
<ul>
<li>有 field</li>
<li>不需要額外檔案（如 <code>.proto</code>）去描述</li>
</ul>
<p><strong>gRPC</strong></p>
<ul>
<li><em>Apache Thrift</em></li>
<li><em>JSON RPC</em></li>
</ul>
<p>關於 gRPC 推薦的文章：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0">比較 gRPC 服務與 HTTP API</a></li>
</ul>
<h2 id="結論-1"><a class="header" href="#結論-1">結論</a></h2>
<ol>
<li>JSON
你需要一個 http client 來呼叫眾多 API Endpoint，訊息格式也需要有額外的 Schema 定義</li>
<li>GraphQL
你還是需要一個 http client，但是這次只需要對應一個端點，而且可以自己組織查詢內容</li>
<li>gRPC
你連 http client 都不用，套件會幫你產出這些呼叫的程式邏輯，而你只需要像寫一般 function 一樣呼叫即可</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="說明-1"><a class="header" href="#說明-1">說明</a></h2>
<p>產品都需要向使用者展示部分的<strong>承諾</strong>，例如：</p>
<ul>
<li>要求在 100ms 內回應（Latency）</li>
<li>1 年當中僅有 1 小時以內的時間服務可能無法使用</li>
<li>任何變動都會保證一年內的向後相容</li>
</ul>
<p>這類保證，稱為 SLA（Service Level Agreement）。</p>
<blockquote>
<p>SLA 通常由多個 SLO（Service Level Objective）組成，例如：
一份 SLA 提供 <code>快速且安全的支付金錢</code>，其中的 <code>保證不會重複扣款</code>即為 SLO</p>
</blockquote>
<blockquote>
<p>SLI（Service Level Indicator）即是 SLO 的指標，例如
目標在 100ms 內回應，實際測試為平均於 80ms 內回應</p>
</blockquote>
<p>好的服務 <code>SLO / SLI</code> 需大於等於 <code>1</code>。</p>
<h3 id="分散式系統中的意義"><a class="header" href="#分散式系統中的意義">分散式系統中的意義</a></h3>
<p>若要求在一個服務有特定的 SLO，就必須同時計算該服務中所有會使用的子服務的 SLO。</p>
<pre><code>   ┌───────────────────────────┐
   │         Application       │
   │   ┌───────────────────┐   │  ┌────┐
   │   │     Service       ├───┴──►User│
   │   └────▲──────────▲───┘100ms └────┘
   │        │          │       │
   │    30ms│      40ms│       │
   │    ┌───┴──┐   ┌───┴──┐    │
   │    │ API1 │   │ API2 │    │
   │    └──────┘   └──────┘    │
   │                           │
   └───────────────────────────┘
</code></pre>
<blockquote>
<p>有時候，產品過於複雜沒辦法產出完整的流程圖，事實的簡化或增加 Tracing 都可以幫助產出。</p>
</blockquote>
<hr />
<h2 id="load-test"><a class="header" href="#load-test">Load Test</a></h2>
<p>Load Test 目的即是計算出 SLI。</p>
<blockquote>
<p>Load Test 和 Stress Test 差在哪裡？</p>
</blockquote>
<p>Latency 代表從<code>事件觸發</code>到<code>事件回應</code>的時間差，此處並不包含錯誤回應的狀況。</p>
<blockquote>
<p>以下範例，都將以 Latency 為 SLO，並計算之。</p>
</blockquote>
<hr />
<h2 id="baseline"><a class="header" href="#baseline">Baseline</a></h2>
<p>測試重要的一點是要有一個基準點，一個產品可以有多種 Baseline</p>
<p>例如：</p>
<ul>
<li>在不做任何外部請求之下的 Latency</li>
<li>使用的框架所限制的 Latency</li>
</ul>
<blockquote>
<p>不同的 Baseline 會有自己的意義，根據需求制定出理想的 Baseline。</p>
</blockquote>
<h3 id="範例"><a class="header" href="#範例">範例</a></h3>
<p>以 Node.js 這語言所能做出最單純的 server 為 Baseline：</p>
<pre><code class="language-javascript=">require(&quot;http&quot;)
  .createServer((req, res) =&gt; res.end('ok'))
  .listen(80, () =&gt; null);
</code></pre>
<p>依此觀察出，在統一機器規格下任何要求在 Node.js 這語言有超越其 Latency 都是沒意義的。</p>
<blockquote>
<p>在追求更好的 Latency 時，或許該考慮其他語言，如 C++ 或 Rust。
但此時便需要權衡其他考量，如：會使用該語言的人數，社群發展程度等等。</p>
</blockquote>
<h3 id="latency"><a class="header" href="#latency">Latency</a></h3>
<table><thead><tr><th>Stat</th><th>2.5%</th><th>50%</th><th>97.5%</th><th>99%</th><th>Avg</th><th>Stdev</th><th>Max</th></tr></thead><tbody>
<tr><td>Latency</td><td>0ms</td><td>0ms</td><td>0ms</td><td>0ms</td><td>0.01ms</td><td>0.08ms</td><td>9.45ms</td></tr>
<tr><td>Req/Sec</td><td>42,751</td><td>39,039</td><td>36,703</td><td>29,487</td><td>38,884.14</td><td>1,748.17</td><td>29,477</td></tr>
</tbody></table>
<p><img src="https://i.imgur.com/sDcMyqC.png" alt="" /></p>
<p>其中的 <code>29487 個每秒請求量</code>即是 TP99（Top Percentile）下的基準點。</p>
<blockquote>
<p>有時會認為 1% 是極端值，應該忽略。然而在網路世界中，一個使用者常常會需要針對一個網頁做出很多請求。若以一個頁面需要 40 個資源來計算，在跑第五個頁面之後，有近乎 0.003 % 的機率使用者 <strong>不會</strong> 觸發到 95% 的狀況。
<a href="https://www.youtube.com/watch?v=lJ8ydIuPFeU">How NOT to Measure Latency</a></p>
</blockquote>
<h2 id="使用-reverse-proxy---haproxy"><a class="header" href="#使用-reverse-proxy---haproxy">使用 Reverse Proxy - HAProxy</a></h2>
<table><thead><tr><th>Percentile</th><th>With Proxy</th><th>Without</th></tr></thead><tbody>
<tr><td>99.9%</td><td>1ms</td><td>1ms</td></tr>
<tr><td>99.99%</td><td>2ms</td><td>2ms</td></tr>
<tr><td>99.999%</td><td>5ms</td><td>3ms</td></tr>
</tbody></table>
<p>得到 <code>19967 個每秒請求量</code>，相比於基準點 <code>29487</code>，看得出在最單純的應用程式下增加 r-proxy 會讓應用程式變慢。</p>
<p>但若考慮真正的應用程式，假如回應時間為 100ms，使用 r-proxy 雖會增加回應時間，卻僅僅增加 1~2ms，整體效益還是大於其消耗的效能。</p>
<h2 id="若考慮-http-compression"><a class="header" href="#若考慮-http-compression">若考慮 HTTP Compression</a></h2>
<p>上述例子僅考慮最基礎的框架效能，若為了壓縮網路流量</p>
<ul>
<li>套用 compression，對於效能會有什麼影響？</li>
<li>再加上 r-prxoy 又會有什麼影響？</li>
</ul>
<h3 id="latency-1"><a class="header" href="#latency-1">Latency</a></h3>
<table><thead><tr><th>Percentile</th><th>With Proxy</th><th>Without</th></tr></thead><tbody>
<tr><td>99%</td><td>47ms</td><td>53ms</td></tr>
<tr><td>99.9%</td><td>50ms</td><td>57ms</td></tr>
<tr><td>99.99%</td><td>52ms</td><td>62ms</td></tr>
<tr><td>99.999%</td><td>53ms</td><td>64ms</td></tr>
</tbody></table>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>上一份報告討論各種服務間的溝通方式：</p>
<ul>
<li>JSON over HTTP</li>
<li>GraphQL</li>
<li>gRPC</li>
</ul>
<p>究竟哪一項是真正有效率的？</p>
<pre><code>  ┌────────────────────────┐          ┌──────────────┐
  │        VPS client      │          │  VPS server  │
  │ ┌─────────┐  ┌───────┐ │          │ ┌──────────┐ │
  │ │Load Test├──►web-api├─┼──────────┼─►recipe-api│ │
  │ └─────────┘  └───────┘ │          │ └──────────┘ │
  │                        │ protocol │              │
  └────────────────────────┘          └──────────────┘
</code></pre>
<h3 id="結果"><a class="header" href="#結果">結果</a></h3>
<table><thead><tr><th>Percentile</th><th>JSON</th><th>GraphQL</th><th>gRPC</th></tr></thead><tbody>
<tr><td>99%</td><td>10ms</td><td>13ms</td><td>24ms</td></tr>
<tr><td>99.9%</td><td>18ms</td><td>22ms</td><td>32ms</td></tr>
<tr><td>99.99%</td><td>26ms</td><td>36ms</td><td>82ms</td></tr>
<tr><td>99.999%</td><td>48ms</td><td>67ms</td><td>82ms</td></tr>
</tbody></table>
<h3 id="討論"><a class="header" href="#討論">討論</a></h3>
<p>我們知道 GraphQL 的價值在於可以在一個 request 中取得所有訊息，且不需要針對每個場景對外開出一個 endpoint。</p>
<p>有時為了追求開發效率，而會捨棄部分產品效率，這時便要權衡產品的特性較偏向於哪邊。</p>
<p>除此之外 JSON 的解析在 v8 engine 中，效率已經被極致的壓縮了，所以相對而言，利用 Buffer 做 binary 解析的 gRPC 在效能上就矮了一截。由於其特性，讓他在 C++ 這類編譯過的程式碼中有較高的效能，而不額外處理 GC 這類事件。</p>
<h2 id="結論-2"><a class="header" href="#結論-2">結論</a></h2>
<ol>
<li>SLA 是面向很多的指標，有時必須權衡</li>
<li>正確的評估符合自己的指標，例如：自動填寫 vs 銀行開戶</li>
<li>在做 load testing 時，需要注意產品可能的流量高低峰</li>
<li>要盡量減少雜音（noisy neighbor），盡量在類似線上的環境中測試</li>
<li>一個產品究竟該開幾個（多少 CPU/Memory）機器來滿足線上流量？</li>
</ol>
<h3 id="方向"><a class="header" href="#方向">方向</a></h3>
<ol>
<li>觀察線上環境現有的流量高峰，並制定出符合商務邏輯的 Latency（SLO）。</li>
<li>制定單位：一個 Docker container、一台機器、EC2</li>
<li>找出在滿足 TP99 下的請求數</li>
<li>增加單位，反覆測試直到達到能容納線上環境的數量</li>
</ol>
<h4 id="範例-1"><a class="header" href="#範例-1">範例</a></h4>
<p>若希望產品能在 50ms 內回應請求，並得出線上環境高峰約每秒 20 （或每分 1200 或每時 72000）個請求。</p>
<p>啟用一個 Docker container 時，如要在 TP99 內回應 50ms 以下，僅能接受每秒 6 個請求。</p>
<p>再增加一個 Docker container，此時能接受每秒 10 個，依序往下加。
最終得到 4 個 container 為合理數量。</p>
<h3 id="工具"><a class="header" href="#工具">工具</a></h3>
<p>上述所有測試，皆是使用 <a href="https://github.com/mcollina/autocannon">autocannon</a> 這軟體測試，相關代碼模式皆為：</p>
<pre><code class="language-bash=">$ autocannon -d 60 -c 10 -l http://localhost:3000
</code></pre>
<blockquote>
<p>其意義在於：建立 10 個連線（<code>-c</code>），並持續（<code>-d</code>）60 秒，並展示詳盡的結果（<code>-l</code>），預設每個連線每秒打 1 次請求（<code>-p</code>）</p>
</blockquote>
<p>對於該使用何種工具，其實不無特別要求，但是對於如何解讀結果，仍推薦 <a href="https://youtu.be/lJ8ydIuPFeU?t=2042">How NOT to Measure Latency</a> 這部影片</p>
<p>若是多項服務合計的 latency（或甚至全公司），這時使用同一種工具就顯得重要了。</p>
<h3 id="微實作"><a class="header" href="#微實作">微實作</a></h3>
<p><a href="https://github.com/104corp/vip3-auth/tree/master/stress-test/2021-05">auth</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="說明-2"><a class="header" href="#說明-2">說明</a></h2>
<p>應用程式是需要維運的，分散式系統的維運和傳統上有什麼差異呢？</p>
<p>本章會依序介紹 Log、Tracing、Metric、Alert 和 Health Check。</p>
<h3 id="log"><a class="header" href="#log">Log</a></h3>
<p>在本地端測試時，時常用 <code>console.log</code> 或 <code>print</code> 這類函示來確認請求在執行過程中沒有發生什麼意料之外的事。</p>
<p>若在線上部署後，我要怎麼從遠在他方的 server 中取得相關訊息？</p>
<p>下面會介紹 <a href="https://www.elastic.co/what-is/elk-stack">ELK</a>（<code>Elasticsearch</code>, <code>Logstash</code>, and <code>Kibana</code>）怎麼讓你拿到 server 的 log 資訊。</p>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>若一個請求歷程會經過多項服務，我要怎麼區分不同的請求？</p>
<blockquote>
<p>例如：發現 A 服務在和 B 服務請求資料時，得到錯誤資料。
於是接著查看 B 服務的 log，然而同一時間卻有很多請求，茫茫大海如何尋？</p>
</blockquote>
<p>此時就可以使用 Tracing 的機制，範例中會使用 <a href="https://zipkin.io">Zipkin</a>。</p>
<pre><code>┌────┐ Request┌───────┐ Request┌──────────┐
│user├────────►web-api├────────►recipe-api│
└────┘        └───────┘        └──────────┘
</code></pre>
<blockquote>
<p><code>request ID</code> 代表各個請求的 ID，必須是不能重複的字串。</p>
</blockquote>
<h3 id="metric"><a class="header" href="#metric">Metric</a></h3>
<p>除了針對單一請求的流程檢閱，若我要做統計呢？</p>
<blockquote>
<p>例如：機器的 CPU 使用率、回應 4xx/5xx 的比率、API 使用分佈</p>
</blockquote>
<p>這一類需要累積的資料，我們便稱其為 Metric，範例中會使用 <a href="https://graphiteapp.org">Graphite</a>，<a href="https://github.com/statsd/statsd">StatsD</a> 和 <a href="https://grafana.com">Grafana</a>。</p>
<h3 id="alert"><a class="header" href="#alert">Alert</a></h3>
<p>有了 Metric，我們便可以設定些閥值，來通知開發人員以及早得知服務的狀態。</p>
<blockquote>
<p>例如 5xx 比率超過 3% 時，提出警告通知</p>
</blockquote>
<p>範例中會使用 <a href="https://grafana.com">Grafana</a>。</p>
<h3 id="health-check"><a class="header" href="#health-check">Health Check</a></h3>
<p>若服務的依賴（例如 DB）連線斷掉或甚至服務本身斷線時，我們能否及早知道？同時自動重新建立連線，或甚至重新啟動該服務。</p>
<p>範例中會使用 <a href="http://www.haproxy.org">HAProxy</a></p>
<h3 id="比較"><a class="header" href="#比較">比較</a></h3>
<table><thead><tr><th>種類</th><th>多服務才有意義</th><th>功能</th><th>所屬（概略）</th></tr></thead><tbody>
<tr><td>Log</td><td>X</td><td>Debug</td><td>Dev</td></tr>
<tr><td>Tracing</td><td>O</td><td>Debug</td><td>Dev-Ops</td></tr>
<tr><td>Metric</td><td>X</td><td>統計</td><td>Ops</td></tr>
<tr><td>Alert</td><td>X</td><td>分析</td><td>Dev-Ops SE</td></tr>
</tbody></table>
<h2 id="實作"><a class="header" href="#實作">實作</a></h2>
<p>接下來進入一系列實作。</p>
<h3 id="log-1"><a class="header" href="#log-1">Log</a></h3>
<p><code>ELK</code> 是 <a href="https://www.elastic.co">Elastic</a> 開發的開源產品，其開發的不僅僅是 <code>ELK</code> 這三項產品。</p>
<p>本範例僅會討論 <code>ELK</code> 代表的 Elasticsearch、Logstash、Kibana 這三個，其中各產品定位和功能如下。</p>
<h4 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h4>
<p>一種資料庫，並對外提供 API，會高效的搜尋相關資訊。並且有其標準的 query 語法。</p>
<blockquote>
<p>Elasticsearch is fast. Really, really fast.</p>
</blockquote>
<blockquote>
<p>Elasticsearch 擁有很多功能，本次僅會示範幾種，若需要更多資訊，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">詳見</a>。</p>
</blockquote>
<h4 id="logstash"><a class="header" href="#logstash">Logstash</a></h4>
<p>Elasticsearch 是一種資料庫，但是儲存的資料需要有人給他，這便是 Logstash 的功能。負責把收到的資料整合送給 Elasticsearch。</p>
<blockquote>
<p>送什麼資料是由應用程式方決定的，可以是 log file、HTTP 等。
本範例是透過 HTTP on UDP 來傳送。</p>
</blockquote>
<h4 id="kibana"><a class="header" href="#kibana">Kibana</a></h4>
<p>Elasticsearch 是一種資料庫，但是並未提供 UI 介面，這時 Kibana 就是把 API 轉成可讓人透過網頁的方式來操作。</p>
<h4 id="架構圖"><a class="header" href="#架構圖">架構圖</a></h4>
<pre><code>                ┌────────────────────────────┐
                │            ELK             │
┌─────────┐     │ ┌────────┐                 │
│ Browser ├─────┼─► Kibana │ ┌─────────────┐ │
└─────────┘     │ └────────┘ │Elasticsearch│ │
                │            └─────────────┘ │
┌─────────┐ UDP │ ┌──────────┐               │
│   APP   ├─────┼─► Logstash │               │
└─────────┘     │ └──────────┘               │
                └────────────────────────────┘
</code></pre>
<h4 id="範例程式碼"><a class="header" href="#範例程式碼">範例程式碼</a></h4>
<p><a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-http-logs.ts">web-api</a></p>
<p>對使用來說，不需要去考慮傳送到 Logstash 的邏輯</p>
<pre><code class="language-javascript=">logger.info(
  {
    path: req.url,
    method: req.method,
    ip: req.ip,
    ua: req.headers['user-agent'] || null,
  },
  'request-incoming',
);
</code></pre>
<blockquote>
<p>無論用什麼格式撰寫 log，統一就好。</p>
</blockquote>
<p>初始化 logger</p>
<pre><code class="language-javascript=">const client = dgram.createSocket('udp4');
const stream = {
  write: (msg: string) =&gt; {
    client.send(msg, LS_PORT, LS_HOST);
  },
};
const logger = pino({ level: 'trace' }, stream);
</code></pre>
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<ul>
<li><a href="https://datadoghq.com">Datadog</a></li>
<li><a href="https://sumologic.com">Sumo Logic</a></li>
<li><a href="https://splunk.com">Splunk</a></li>
<li>Cloud (AWS, GCP, ELK)</li>
</ul>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<p>其架構會和 Log 很像，Elasticsearch 也包含這類的 query 語法。
其重點差異便是在 log 處理對象為單一請求，而 metrics 處理的是服務在累積流量或時間後的狀態，如<a href="feedback/distributed-systems-with-node.js/observability.html#metric">上</a>所述。</p>
<p>範例中會使用的是 <code>Grafana</code>、<code>Graphite</code> 和 <code>StatsD</code>。</p>
<h4 id="架構"><a class="header" href="#架構">架構</a></h4>
<pre><code>                ┌──────────────────────────┐
                │        Metrics           │
┌─────────┐     │ ┌─────────┐              │
│ Browser ├─────┼─► Grafana │ ┌──────────┐ │
└─────────┘     │ └─────────┘ │ Graphite │ │
                │             └──────────┘ │
┌─────────┐ UDP │ ┌────────┐               │
│ Service ├─────┼─► StatDs │               │
└─────────┘     │ └────────┘               │
                └──────────────────────────┘
graph LR
  0[Browser]
  1[Service]
  subgraph Metrics
    2[Grafana]
    3[Graphite]
    4[StatsD]
  end
  0 --&gt; 2
  2 --&gt; 3
  3 --&gt; 2

  1 -- UDP --&gt;4
  4 --&gt; 3
</code></pre>
<blockquote>
<p>和 log 非常相似，這裡就不贅述其意義。</p>
</blockquote>
<h4 id="程式碼"><a class="header" href="#程式碼">程式碼</a></h4>
<p><a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-http-metrics.ts">web-api</a></p>
<p>初始化 client</p>
<pre><code class="language-javascript=">const client = new StatsDClient({
  host: 'localhost',
  port: 8125,
  prefix: 'web-api',
});
</code></pre>
<p>統計請求時間和次數</p>
<pre><code class="language-javascript=">const begin = new Date();

await got(`http://${TARGET}/recipes/42`);

client.timing('outbound.recipe-api.request-time', begin);
client.increment('outbound.recipe-api.request-count');
</code></pre>
<p>統計系統資源</p>
<pre><code class="language-javascript=">setInterval(() =&gt; {
  client.gauge('server.conn', server.connections);

  const m = process.memoryUsage();
  client.gauge('server.memory.used', m.heapUsed);
  client.gauge('server.memory.total', m.heapTotal);

  const h = v8.getHeapStatistics();
  client.gauge('server.heap.size', h.used_heap_size);
  client.gauge('server.heap.limit', h.heap_size_limit);

  // try to mock memory heap
  fs.readdir(__dirname, (err, list) =&gt; {
    if (err) return;
    client.gauge('server.descriptors', list.length);
  });
}, 10_000);
</code></pre>
<blockquote>
<p>範例中，把記憶體等相關資訊放在應用程式中。
實際上，為了避免應用程式斷線，導致收集不到服務的資訊，這類的資料收集應在服務外使用。</p>
</blockquote>
<h4 id="alternative-1"><a class="header" href="#alternative-1">Alternative</a></h4>
<ul>
<li><code>Graphite</code> -&gt; Prometheus, InfluxDB</li>
<li><code>StatsD</code> -&gt; cAdvisor, MetricBeat</li>
</ul>
<h3 id="tracing-1"><a class="header" href="#tracing-1">Tracing</a></h3>
<p>在分散式系統中，多個服務間的溝通或請求都可能在過程中得到非預期的結果，為了能快速找到問題點，需要辨別同一支請求在各個服務中的位置。</p>
<blockquote>
<p>透過建立 request ID 來辨別同一支請求在多個服務中的位置。</p>
</blockquote>
<h4 id="架構-1"><a class="header" href="#架構-1">架構</a></h4>
<pre><code>               ┌────────────────┐
               │       APP      │
┌────────┐     │  ┌─────────┐   │ info ┌────────────┐
│ Client ├─────┼──► web-api ├───┼─────►│            │
└────────┘     │  └──▲────┬─┘   │      │            │
           Response  │    │Request ID  │   Zipkin   │
               │ ┌───┴────▼───┐ │      │            │
               │ │ recipe-api ├─┼──────┤            │
               │ └────────────┘ │ info └────────────┘
               └────────────────┘
</code></pre>
<p>產出範例：</p>
<pre><code class="language-mermaid">gantt
dateFormat m:s
axisFormat %S
todayMarker off
title Request 1

task1 :des1, 10:1, 5s

fetch :des2, 10:7, 10s
recipe :des4, 10:8, 8s

task2 :des3, 10:18, 3s
</code></pre>
<blockquote>
<p>web-api 會傳送 <code>task1</code>、<code>fetch</code> 和 <code>task2</code>
recipe-api 會傳送 <code>recipe</code></p>
</blockquote>
<h4 id="程式碼-1"><a class="header" href="#程式碼-1">程式碼</a></h4>
<p><a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-http-zipkin.ts">web-api</a></p>
<pre><code class="language-javascript=">const tracer = new Tracer({
  ctxImpl,
  recorder,
  localServiceName: 'web-api',
  sampler: new sampler.CountingSampler(1),
});
</code></pre>
<p>紀錄請求開始時和結束時</p>
<pre><code class="language-javascript=">app.use(expressMiddleware({ tracer }));
</code></pre>
<p>紀錄需要執行 100ms 的任務</p>
<pre><code class="language-javascript=">await tracer.local&lt;Promise&lt;void&gt;&gt;(
  'do_some_task',
  () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 100)),
);
</code></pre>
<p>使用包裝後的 <code>got</code> 來去請求，在使用時不需要考慮其 tracing 邏輯。</p>
<pre><code class="language-javascript=">await instance(`http://${TARGET}/recipes/42`).json();
</code></pre>
<pre><code class="language-javascript=">const instance = got.extend({
  hooks: {
    init: [
      (opts) =&gt; opts._zipkin.parentId = tracer.id,
    ],
    beforeRequest: [
      (opts) =&gt; {
        // ...
      },
    ],
    afterResponse: [
      (res) =&gt; {
        // ...
      },
    ],
    beforeError: [
      (err) =&gt; {
        // ...
        return err;
      },
    ],
  },
});
</code></pre>
<p><a href="https://github.com/evan361425/distributed-node/blob/master/src/recipe-api/producer-http-zipkin.ts">recipe-api</a></p>
<p><img src="https://i.imgur.com/hAfYQhP.png" alt="" /></p>
<h3 id="alert-1"><a class="header" href="#alert-1">Alert</a></h3>
<p>Demo in production</p>
<h3 id="health-check-1"><a class="header" href="#health-check-1">Health Check</a></h3>
<p>這大部分會和 Alert 一起實作，目的是持續打特定 route 去得知服務現有狀況。</p>
<p>但現有狀況會有些模糊地帶，例如：</p>
<p>有產品使用 cache 去達到 SLA。當 cache 失去運作，對應用程式來說仍能運行。但整體效率會降低，進而提高 Latency，這時服務的狀態算是健康還是不健康？</p>
<blockquote>
<p>這種模糊地帶被稱作 <code>degraded</code>，至於該怎麼處理，就和商務邏輯的實作有關了。</p>
</blockquote>
<h4 id="範例-2"><a class="header" href="#範例-2">範例</a></h4>
<blockquote>
<p>範例中，會用 r-proxy 做 health check 且應用程式綁在一起。
但實作上，仍建議讓應用程式外的產品或甚至外單位的產品去做 health check。
例如：<a href="https://pagerduty.com">PagerDuty</a>、<a href="https://nagios.org">Nagios</a>、<a href="https://pingdom.com/">Pingdom</a>。
除了 r-proxy，專做 health check 的開源軟體有：<a href="https://cabotapp.com/">Cabot</a>。</p>
</blockquote>
<p>HAProxy 的設定黨</p>
<pre><code># ...

backend web-api
  option httpchk GET /health
  server web-api-1 localhost:3001 check
  server web-api-2 localhost:3002 check
</code></pre>
<p><a href="https://github.com/evan361425/distributed-node/blob/master/src/web-api/consumer-http-healthcheck.ts">web-api</a></p>
<pre><code class="language-javascript=">app.get('/health', (_req, res) =&gt; {
  return res.send('OK');
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="服務從一個變多個"><a class="header" href="#服務從一個變多個">服務從一個變多個</a></h2>
<p>問題往往就發生在當服務從一個變成多個時。</p>
<h3 id="protocol-1"><a class="header" href="#protocol-1">Protocol</a></h3>
<p><strong>JSON</strong> - 當你只有一個 API Endpoint，足矣。</p>
<blockquote>
<p>但是當你有越來越多 Endpoint 甚至同一時間需要各個 Endpoint 的資源...</p>
</blockquote>
<p><strong>GraphQL</strong> - 只需要對應一個端點，就可以獲得多個 API 的資訊且可以自行組織查詢內容</p>
<blockquote>
<p>但是 API 的行為越來越複雜，牽涉到多種邏輯...</p>
</blockquote>
<p><strong>gRPC</strong> - 只需要專心撰寫程式邏輯，相關的 HTTP client 皆已經處理完。</p>
<h3 id="sla-and-load-test"><a class="header" href="#sla-and-load-test">SLA and Load Test</a></h3>
<p>怎麼確保產品在經過多次傳輸後仍能維持可預期的保證</p>
<ol>
<li>SLO</li>
<li>Load Test</li>
<li>Baseline</li>
</ol>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<p>當產品越來越多，怎麼快速精準的獲取應用、服務、設備的資訊。</p>
<ul>
<li>Log</li>
<li>Metric</li>
<li>Tracing</li>
<li>Alert</li>
<li>Health Check</li>
</ul>
<h2 id="部署方式"><a class="header" href="#部署方式">部署方式</a></h2>
<p>有很多種方法可以提升服務的數量，各種方式都需權衡：</p>
<ul>
<li>可攜帶性 - 相依套件須一併攜帶，包括 Binaries Depending</li>
<li>效率 - 每次部署需消耗的成本</li>
<li>安全性 - 機敏資訊的暴露</li>
<li>脆弱性 - 相依套件版本的衝突等</li>
</ul>
<h3 id="比較-1"><a class="header" href="#比較-1">比較</a></h3>
<p><img src="https://i.imgur.com/eaViL43.png" alt="" /></p>
<ul>
<li>實體機 - 若和其他服務（如 Load Balancer）有套件的衝突，會很麻煩。</li>
<li>VM - 適合 DB 和其他需要儲存穩定狀態的應用程式。</li>
<li>Container - 適合高迭代、高部署率的應用程式。</li>
</ul>
<blockquote>
<p>Container 包括 Image、Port Mapping、Volume Mappings
Volume 就是管理 Container 端和 Host 端的 filesystem</p>
</blockquote>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>Docker 是一個管理、建置 Container 的工具，其主要有三個工具：</p>
<ol>
<li><em>dockerd</em> daemon，對外提供 API，進行 Container 的建置和管理</li>
<li><em>Docker CLI</em> 提供語法對 API 進行呼叫和設定。</li>
<li><em>Docker Hub</em></li>
</ol>
<blockquote>
<p><em>Docker Desktop</em>
Docker 是執行在 Linux 之上的工具，若機器不是 Linux，就會需要 <em>Docker Desktop</em>。
其不僅可以建立 VM 來模擬 Linux 環境，也提供其他好用功能，如 UI 和 Kubernetes 的整合。</p>
</blockquote>
<pre><code class="language-mermaid">graph TD

  subgraph Host OS
    Filesystem
  end

  subgraph Container
    0[Image]
    Volume --&gt; Filesystem
    Filesystem --&gt; Volume
    Port
  end
  1[Docker] --&gt; 0
  0 --&gt; 1
  2[Daemon] -- HTTP --&gt; 1
  3[Docker CLI] --&gt; 2
  4[Docker Hub] --&gt; 2
  2 --&gt; 4

</code></pre>
<h3 id="docker-image"><a class="header" href="#docker-image">Docker Image</a></h3>
<p>把應用程式包裝成 Image 再依此建立 Container。
應用程式大部分都需要建立在特定環境之上，以 Node.js 的應用程式為例：</p>
<pre><code class="language-mermaid">graph TB
  subgraph Linux
    0[&quot;/usr/bin&quot;]
  end
  subgraph Node.js
    1[&quot;/usr/bin/node&quot;]
  end
  subgraph Application
    2[&quot;/srv/server.js&quot;]
  end
  0 --&gt; 1
  1 --&gt; 2
</code></pre>
<blockquote>
<p>每個環境都稱為一組 stage，如 <code>Linux</code>、<code>Node.js</code> 和 <code>Application</code>。
每個 stage 中會有很多層 layer，分別代表建立過程的一個步驟。</p>
</blockquote>
<p>以 Node.js 並包裝在 Alpine 之上的 Image 為例：</p>
<pre><code class="language-bash=">$ docker pull node:lts-alpine
c9b1b535fdd9: Pull complete
750cdd924064: Downloading [==&gt;              ]  2.485MB/34.53MB
2078ab7cf9df: Download complete
02f523899354: Download complete
</code></pre>
<table><thead><tr><th>#</th><th>Layer</th><th>Size</th></tr></thead><tbody>
<tr><td>1</td><td>ADD file ... in /...</td><td>2.69 MB</td></tr>
<tr><td>2</td><td>CMD [&quot;/bin/sh&quot;]</td><td>0 B</td></tr>
<tr><td>3</td><td>ENV NODE_VERSION=14.17.3</td><td>0 B</td></tr>
<tr><td>4</td><td>/bin/sh -c addgroup -g 1000 ...</td><td>34.53 MB</td></tr>
<tr><td>5</td><td>ENV YARN_VERSION=1.22.5</td><td>0 B</td></tr>
<tr><td>6</td><td>/bin/sh -c apk add --no-cache ...</td><td>2.14 MB</td></tr>
<tr><td>7</td><td>COPY file ... in /usr/...</td><td>281 B</td></tr>
<tr><td>8</td><td>ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</td><td>0 B</td></tr>
<tr><td>9</td><td>CMD [&quot;node&quot;]</td><td>0 B</td></tr>
</tbody></table>
<blockquote>
<p>Image 大小為 39.35 MB，<a href="https://hub.docker.com/layers/node/library/node/lts-alpine/images/sha256-5c33bc6f021453ae2e393e6e20650a4df0a4737b1882d389f17069dc1933fdc5">連結</a></p>
</blockquote>
<blockquote>
<p>有改變 filesystem 的步驟（會改變 Image 大小），才會列出來。</p>
</blockquote>
<blockquote>
<p>SHA 值計算方式是上一個 SHA 值加上現行的指令組出來的。</p>
</blockquote>
<p>若改為 Debian（預設值）則為：</p>
<pre><code class="language-bash=">$ docker pull node:lts
199ebcd83264: Pull complete
ddbb155879c0: Pull complete
c194bbaa3d8b: Pull complete
6154ac87d7f3: Pull complete
0c283e88ced7: Pull complete
dba101298560: Pull complete
1d8bfd4e555f: Downloading [=====&gt;       ] 7.56MB/33.38MB
757e41ffbdcc: Download complete
6e055c4b8721: Download complete
</code></pre>
<table><thead><tr><th>#</th><th>Layer</th><th>Size</th></tr></thead><tbody>
<tr><td>1</td><td>ADD file ... in ...</td><td>43.28 MB</td></tr>
<tr><td>2</td><td>CMD [&quot;bash&quot;]</td><td>0 B</td></tr>
<tr><td>3</td><td>/bin/sh -c set -eux; apt-get ...</td><td>10.77 MB</td></tr>
<tr><td>4</td><td>/bin/sh -c set -ex; if ...</td><td>4.14 MB</td></tr>
<tr><td>5</td><td>/bin/sh -c apt-get update &amp;&amp; ...</td><td>47.46 MB</td></tr>
<tr><td>6</td><td>/bin/sh -c set -ex; apt-get ...</td><td>204.5 MB</td></tr>
<tr><td>7</td><td>/bin/sh -c groupadd --gid 1000 ...</td><td>4.09 KB</td></tr>
<tr><td>8</td><td>ENV NODE_VERSION=14.17.3</td><td>0 B</td></tr>
<tr><td>9</td><td>/bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg ...</td><td>33.38 MB</td></tr>
<tr><td>10</td><td>ENV YARN_VERSION=1.22.5</td><td>0 B</td></tr>
<tr><td>11</td><td>/bin/sh -c set -ex ...</td><td>2.23 MB</td></tr>
<tr><td>12</td><td>COPY file ... in ...</td><td>295 B</td></tr>
<tr><td>13</td><td>ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</td><td>0 B</td></tr>
<tr><td>14</td><td>CMD [&quot;node&quot;]</td><td>0 B</td></tr>
</tbody></table>
<blockquote>
<p>Image 大小為 345.75 MB，<a href="https://hub.docker.com/layers/node/library/node/lts/images/sha256-c31c7a8a41bcef8e260953bae91e65839f2cc29e5fbaa89407859ff7b7f144e3">連結</a>。</p>
</blockquote>
<blockquote>
<p>Container 部署實作上仍建議以較小的 Image 為基底，除了加速部署流程外，較小的檔案面積理論上也能降低被攻擊的機會。</p>
</blockquote>
<p><img src="https://i.imgur.com/eaViL43.png" alt="" /></p>
<h3 id="實作-1"><a class="header" href="#實作-1">實作</a></h3>
<p>相信了解 Image 製作原理後，對於實作就不會有太大問題，這裡有實作相關的文件，有興趣可以去查看</p>
<ul>
<li><a href="feedback/distributed-systems-with-node.js/./../../essay/made-container.html">以 Node.js 為基礎的製作範例</a></li>
<li><a href="https://docs.docker.com/language/">各語言的範例</a> - 官網</li>
</ul>
<h3 id="和-container-的互動"><a class="header" href="#和-container-的互動">和 Container 的互動</a></h3>
<p>透過 Docker CLI 可以和 Container 互動，除了讓我們了解其內部運作過程，也可以幫助我們 Debug。</p>
<h4 id="進入-container"><a class="header" href="#進入-container">進入 Container</a></h4>
<pre><code class="language-bash=">$ docker run -it ubuntu /bin/bash
</code></pre>
<ul>
<li><code>-i</code> 代表要以互動模式進入 Container</li>
<li><code>-t</code> 代表是以 TTY session 進入，和 <code>-i</code> 整合為 <code>-it</code></li>
<li>並使用 <code>bash</code></li>
</ul>
<p>進入後，即可透過 <code>ps -e</code> 輸出所有 process。</p>
<pre><code>PID TTY          TIME CMD
  1 pts/0    00:00:00 bash
 10 pts/0    00:00:00 ps
</code></pre>
<blockquote>
<p>bash 作為初始行為，必須在 PID 1。</p>
</blockquote>
<p>由此可看出，Container 的行為相當單純，不像實際使用的電腦，會有各種服務在背景運作。</p>
<h4 id="對-container-內部下達指令"><a class="header" href="#對-container-內部下達指令">對 Container 內部下達指令</a></h4>
<p><code>docker exec ubuntu /bin/ls /var</code></p>
<h4 id="把檔案丟進-container-中"><a class="header" href="#把檔案丟進-container-中">把檔案丟進 Container 中</a></h4>
<pre><code class="language-bash=">$ curl -o index.html http://example.org
$ docker run --rm -p 8080:80 \
  -v $PWD:/usr/share/nginx/html nginx
</code></pre>
<blockquote>
<p><code>-p</code> 即為前面提到的 port-mappings
<code>-v</code> 即為 volume-mappings（filesystem）</p>
</blockquote>
<h3 id="alternative-2"><a class="header" href="#alternative-2">Alternative</a></h3>
<p>現在已經較少其他管理 Container 的產品：</p>
<ul>
<li>RedHat 有一個已經 archive 的專案 <a href="https://github.com/rkt/rkt">rkt</a></li>
<li><a href="https://opencontainers.org/">Open Container Initiative</a> 則嘗試制訂 container 標準。</li>
</ul>
<h2 id="分散式系統上的應用"><a class="header" href="#分散式系統上的應用">分散式系統上的應用</a></h2>
<p>多個服務要怎麼透過 Docker 建立？有幾個方法：</p>
<ul>
<li><code>docker run exmaple/server1</code> <code>docker run exmaple/server2</code></li>
</ul>
<blockquote>
<p>多次 <code>docker run exmaple/server</code> 去建立不同的應用程式會難管理且容易出錯。</p>
</blockquote>
<ul>
<li>把不同服務包裝成同一個 Image</li>
</ul>
<blockquote>
<p>有時相似的應用程式可以包裝成同一個 Image，如上一次報告提到的 <code>ELK</code>，但是分散式系統上不同的應用程式若包裝成同一個 Image 會讓服務的獨立性消失。</p>
</blockquote>
<p>docker-compose 便是用來解決這一問題的方案。</p>
<p>以上一份 Tracing 中的 Zipkin 為例：</p>
<pre><code class="language-mermaid">graph LR
  0[Client]
  1[Zipkin]
  subgraph APP
    2[web-api]
    3[recipe-api]
  end

  0 --&gt; 2
  2 --&gt; 3
  3 --&gt; 2
  2 -- info --&gt; 1
  3 -- info --&gt; 1
</code></pre>
<p>就可以依此建立 docker-compose.yaml：</p>
<pre><code class="language-yaml=">version: &quot;3.7&quot;
services:
  zipkin:
    image: openzipkin/zipkin-slim:2.19
    ports:
      - 9411:9411
  recipe-api:
    build:
      context: ./recipe-api
      dockerfile: Dockerfile-zipkin
    ports:
      - 4000:4000
    environment:
      ZIPKIN: zipkin:9411
    depends_on:
      - zipkin
  web-api:
    build:
      context: ./web-api
      dockerfile: Dockerfile-zipkin
    ports:
      - 3000:3000
    environment:
      TARGET: recipe-api:4000
      ZIPKIN: zipkin:9411
    depends_on:
      - zipkin
      - recipe-api
</code></pre>
<h2 id="docker-registry"><a class="header" href="#docker-registry">Docker Registry</a></h2>
<p>Docker Hub 提供存放 Image 空間，但對於私人空間的存放數量有限制。
可以根據預算，考慮其他 Docker Registry，例如：</p>
<ul>
<li>JFrog Artifactory</li>
<li>Cloud based</li>
</ul>
<h2 id="註"><a class="header" href="#註">註</a></h2>
<p>這次分享省略</p>
<ul>
<li>上傳 Image 到 Docker Registry</li>
<li>自製 Docker Registry UI</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>上一份報告說明 Container 的價值和建構邏輯。而 Docker 不僅作為包裝應用程式的工具，也幫我們管理 Container。</p>
<p>但是仍有一些狀況需要解決：</p>
<ul>
<li>如何做 Scaling，單一或多台機器</li>
<li>Load Balance</li>
<li>Health Check and Replacement</li>
<li>多服務間的溝通，docker-compose 僅能在單一台機器下協助溝通</li>
<li>新版本的應用程式如何無縫接軌</li>
</ul>
<p>這時便需要一個調度容器（Container）的工具。</p>
<h2 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h2>
<p>Kubernetes 可以解決上述提到的問題。接下來會先簡單介紹其中各名詞代表的意義，然後再實作，這樣對於實作時操作的各個指令就會比較有感。</p>
<h3 id="單位"><a class="header" href="#單位">單位</a></h3>
<p>以下將逐一介紹 Kubernetes 的基本單位。</p>
<ul>
<li>Container</li>
<li>Volume</li>
<li>Pod</li>
<li>Node</li>
<li>Master</li>
<li>Cluster</li>
</ul>
<h4 id="container"><a class="header" href="#container">Container</a></h4>
<p>管理容器化的應用程式，除了 Docker 外，上一份報告提到的 rkt 也是允許的應用程式。</p>
<h4 id="volume"><a class="header" href="#volume">Volume</a></h4>
<p>和 Host 的 filesystem 做連接的服務，對 Container 提供資料存取的地方。</p>
<h4 id="pod"><a class="header" href="#pod">Pod</a></h4>
<p>用來包裝 Container 和 Volume 的單位，一個 Pod 會被分配到一個 IP。若 Pod 中含有多的 Container 的話，各個 Container 會共用該組 IP。</p>
<p>有上述三個單位可以畫出一個圖：</p>
<img style="display: block; margin-left: auto;margin-right: auto" width="50%" src="https://i.imgur.com/ESmuJ0d.png"/>
<h4 id="node"><a class="header" href="#node">Node</a></h4>
<p>如同 Docker 管理 Container 一般，Node 就是管理 Pod 的單位。
一個 Node 底下需要一些輔助工具來幫助管理各個 Pod 和 Container：</p>
<ul>
<li>Kubernetes Daemon（稱作 Kubelet）</li>
<li>Container Daemon（如：Docker）</li>
<li>Network Proxy（稱作 Kube Proxy）</li>
</ul>
<pre><code>┌─────────────────────────────┐
│                             │
│     Kubernetes Node         │
│                             │
│  ┌────────────┐             │
│  │ Kubernetes │   Kubelet   │
│  │     Pod    │             │
│  └────────────┘   Docker    │
│                             │
│  ┌────────────┐  Kube proxy │
│  │ Kubernetes │             │
│  │     Pod    │             │
│  └────────────┘             │
│                             │
└─────────────────────────────┘
</code></pre>
<h4 id="master"><a class="header" href="#master">Master</a></h4>
<p>用來管理 Node，並對外開放 API，提供途徑去操作各個 Node。
如：開發者可以通過 <code>kubectl</code> 透過 Master 去操作各個 Node。
（類似於 <code>Docker CLI</code> 透過 <code>Daemon</code> 去操作各個 <code>Container</code>）</p>
<h4 id="cluster"><a class="header" href="#cluster">Cluster</a></h4>
<p>一組由 Master 和多個 Node 組成的群組。</p>
<h4 id="完整概略圖"><a class="header" href="#完整概略圖">完整概略圖</a></h4>
<p><img src="https://i.imgur.com/mkcGdX3.png" alt="" /></p>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>每次呼叫 Master 做事情，事實上就是指定一個 Cluster 應該有的狀態，如：</p>
<blockquote>
<p>我希望某某 Node 裡面有 10 個版本 2 的 Pod。</p>
</blockquote>
<p>此時 Kubernetes 就會針對該狀態開始做事，不管是降低、升高數量或升降版本的操作都是由 Kubernetes 去執行。</p>
<blockquote>
<p>此處包括執行邏輯，例如預期 10 個 Pod，現有 4 個，需增加 6 個，此處的 6 個就是 Kubernetes 自行去計算出的數字。</p>
</blockquote>
<p>接下來會介紹幾個在本次實作會應用到的觀念。</p>
<ul>
<li>Deployment</li>
<li>Selector</li>
<li>Label</li>
<li>Scheduler</li>
<li>Controller</li>
<li>ReplicaSet</li>
<li>Probe</li>
</ul>
<pre><code>                              ┌─┬─────────┐
                              │L│ Defined │
                              │a│  Pod B  │
                              │b│         │
                              │e│         │
                              │l│         │
                              │ │         │
         ┌──────────┐         │B│         │
kubectl─►│Deployment│         └─┴─────────┘
         └─────┬────┘
               │              ┌─┬─────────┐
               │              │L│ Defined │
               │ Selector     │a│  Pod A  │
               └───────────►  │b│         │
                              │e│         │
                              │l│         │  ┌────────────┐
                              │ │         │  │ ReplicaSet │
                              │A│         │  │            │
                              └─┴─────────┘  │ ┌───────┐  │
┌─┬─────────┐                                │ │Pod A-1│  │
│L│ Defined │                                │ └───────┘  │
│a│  Pod A  │                                │            │
│b│         │Scheduler   ┌─────┐Controller   │ ┌───────┐  │
│e│         ├───────────►│Ready├───────────► │ │Pod A-2│  │
│l│         │Pending     └─────┘Creating     │ └───────┘  │
│ │         │                                │            │
│A│         │                Probe           │ ┌───────┐  │
└─┴─────────┘               ─────────────────┼─►Pod A-N│  │
                             Health Checking │ └───────┘  │
                                             │            │
                                             └────────────┘
</code></pre>
<h4 id="deployment"><a class="header" href="#deployment">Deployment</a></h4>
<p>用來表達部署時欲達成的狀態，通常是最常接觸的工具。</p>
<p>狀態可能包括數量、版本等。</p>
<h4 id="selector"><a class="header" href="#selector">Selector</a></h4>
<p>用來指定特定 Pod 的條件，例如：有高運算需求的就會要求有 <code>machine:physical</code> 這個 Label 的 Pod。</p>
<h4 id="label"><a class="header" href="#label">Label</a></h4>
<p>用來幫 Node 和 Pod 貼標籤，以 Node.js 為例：</p>
<ul>
<li><code>platform:node</code></li>
<li><code>playform-version:v14</code></li>
<li><code>machine:physical</code></li>
<li><code>kernel:3.16</code></li>
<li><code>app:web-api</code> <code>app:recipe-api</code></li>
</ul>
<blockquote>
<p>Label 不必唯一，你可以重複設定一樣的 key，如：<code>platform:node</code>、<code>platform:alpine</code></p>
</blockquote>
<pre><code>                              ┌─┬─────────┐
                              │L│ Defined │
                              │a│  Pod B  │
                              │b│         │
                              │e│         │
                              │l│         │
                              │ │         │
         ┌──────────┐         │B│         │
kubectl─►│Deployment│         └─┴─────────┘
         └─────┬────┘
               │              ┌─┬─────────┐
               │              │L│ Defined │
               │ Selector     │a│  Pod A  │
               └───────────►  │b│         │
                              │e│         │
                              │l│         │
                              │ │         │
                              │A│         │
                              └─┴─────────┘
</code></pre>
<h4 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h4>
<p>Kubernetes 會測試現有環境（如 CPU/Memory）是否適合添加 Pod。若無，則等待。</p>
<p>預設做 Scheduling 的工具為 <em>kube-scheduler</em>。</p>
<h4 id="controller"><a class="header" href="#controller">Controller</a></h4>
<p>用來控制 Kubernetes 各種狀態的控制器，通常開發者不會直接接觸。</p>
<h4 id="replicaset"><a class="header" href="#replicaset">ReplicaSet</a></h4>
<p>除了 ReplicaSet 外，根據需求還有其他種類的群組，如：</p>
<ul>
<li>StatefulSet 是可以提供狀態儲存的群組。</li>
</ul>
<blockquote>
<p>Stateful 的應用程式在這幾次報告都不會討論，因為對於需要儲存狀態的應用程式，其建構、部署的策略是另一項領域。</p>
</blockquote>
<h4 id="probe"><a class="header" href="#probe">Probe</a></h4>
<p>用來做 Health Check。</p>
<pre><code>                                             ┌────────────┐
                                             │ ReplicaSet │
                                             │            │
                                             │ ┌───────┐  │
┌─┬─────────┐                                │ │Pod A-1│  │
│L│ Defined │                                │ └───────┘  │
│a│  Pod A  │                                │            │
│b│         │Scheduler   ┌─────┐Controller   │ ┌───────┐  │
│e│         ├───────────►│Ready├───────────► │ │Pod A-2│  │
│l│         │Pending     └─────┘Creating     │ └───────┘  │
│ │         │                                │            │
│A│         │                Probe           │ ┌───────┐  │
└─┴─────────┘               ─────────────────┼─►Pod A-N│  │
                             Health Checking │ └───────┘  │
                                             │            │
                                             └────────────┘
</code></pre>
<ul>
<li>Ingress</li>
<li>Service</li>
</ul>
<pre><code>                │ Request
┌───────────────▼──────────────┐
│            Ingress           │
├──────┬───────────────────────┤
│      │                       │
│ ┌────▼───┐    ┌────────────┐ │
│ │        ├────►  Service   │ │
│ │ Master │    ┌────────────┤ │
│ │        │    │ Node       │ │
│ └────────┘    │            │ │
│               │   Pod1     │ │
│               │   Pod2     │ │
│               │   ...      │ │
│               └────────────┘ │
│                              │
└──────────────────────────────┘
</code></pre>
<h4 id="service"><a class="header" href="#service">Service</a></h4>
<p>如同 Docker 會決定哪一個 Container 有對外的 port 一樣，Service 也會利用 Selector 決定哪一個 Pod 是可以對外的。
類似於 reverse-proxy 般，決定外部哪些請求可以送進 Pod 裏面。</p>
<blockquote>
<p>在前幾次報告中常常提到 service，其代表的意義是服務或應用程式，有別於此處提到的 Service</p>
</blockquote>
<h4 id="ingress"><a class="header" href="#ingress">Ingress</a></h4>
<p>管理 Cluster 外部的請求。</p>
<h3 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h3>
<p>由上述可知，Kubernetes 擁有非常豐富的功能，並且可以透過多種方式達成同一個目的（例如 dev/stg 的環境分割）。這裡也並未完全涵蓋 Kubernetes 的概念（例如以 <a href="https://etcd.io">etcd</a> 做儲存的演算法）</p>
<blockquote>
<p><em>Apache Mesos</em> 和 <em>Apache Marathon</em> 的組合能達到類似 Kubernetes 的功能。
<em>Docker Swarm</em> 是 <em>Docker</em> 原生的容器化調度工具，但 <em>Docker</em> 已經捨棄並改採和 Kubernetes 的兼容了。</p>
</blockquote>
<h2 id="minikube"><a class="header" href="#minikube">minikube</a></h2>
<p>為了簡化實作上需要做的設定，本次實作會透過 <em>minikube</em> 來操作。<em>minikube</em> 是一個簡化版的 Kubernetes，他減少很多功能的設定，讓使用者可以快速開始實作，並且把 Master/Node 融合再一起。</p>
<ul>
<li>確認 kubectl 的安裝：<code>kubectl version --client</code></li>
</ul>
<blockquote>
<p><code>brew install kubernetes-cli</code></p>
</blockquote>
<ul>
<li>確認 minikube 的安裝：<code>minikube version</code></li>
</ul>
<blockquote>
<p><code>brew install minikube</code></p>
</blockquote>
<h3 id="kubectl"><a class="header" href="#kubectl">kubectl</a></h3>
<ul>
<li>啟動</li>
</ul>
<pre><code class="language-bash=">$ minikube start
😄  minikube v1.20.0 on Darwin 11.4
🎉  minikube 1.22.0 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.22.0
✨  Using the hyperkit driver based on existing profile
💡  To disable this notice, run: 'minikube config set WantUpdateNotification false'

👍  Starting control plane node minikube in cluster minikube
🔄  Restarting existing hyperkit VM for &quot;minikube&quot; ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.6 ...
🔎  Verifying Kubernetes components...
    ▪ Using image k8s.gcr.io/ingress-nginx/controller:v0.44.0
    ▪ Using image kubernetesui/dashboard:v2.1.0
    ▪ Using image docker.io/jettech/kube-webhook-certgen:v1.5.1
    ▪ Using image kubernetesui/metrics-scraper:v1.0.4
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
    ▪ Using image docker.io/jettech/kube-webhook-certgen:v1.5.1
🔎  Verifying ingress addon...
🌟  Enabled addons: storage-provisioner, default-storageclass, ingress, dashboard
🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default
</code></pre>
<ul>
<li>查看現有 Pods</li>
</ul>
<pre><code class="language-bash=">$ kubectl get pods
No resources found in default namespace.
</code></pre>
<p>因為預設使用 <code>default</code> namespace</p>
<ul>
<li>查看所有 namespace</li>
</ul>
<pre><code class="language-bash=">$ kubectl get namespace
NAME                   STATUS   AGE
default                Active   48d
ingress-nginx          Active   48d
kube-node-lease        Active   48d
kube-public            Active   48d
kube-system            Active   48d
kubernetes-dashboard   Active   48d
</code></pre>
<ul>
<li>查看系統的 Pods</li>
</ul>
<pre><code class="language-bash=">$ kubectl get pods --namespace=kube-system
NAME                               READY   STATUS    RESTARTS   AGE
coredns-74ff55c5b-sq5jt            1/1     Running   1          48d
etcd-minikube                      1/1     Running   1          48d
kube-apiserver-minikube            1/1     Running   1          48d
kube-controller-manager-minikube   1/1     Running   1          48d
kube-proxy-vslx5                   1/1     Running   1          48d
kube-scheduler-minikube            1/1     Running   1          48d
storage-provisioner                1/1     Running   2          48d
</code></pre>
<ul>
<li>查看 Node</li>
</ul>
<pre><code class="language-bash=">$ kubectl get nodes
NAME       STATUS   ROLES                  AGE   VERSION
minikube   Ready    control-plane,master   48d   v1.20.2
</code></pre>
<ul>
<li>使用 minikube 的 Docker</li>
</ul>
<pre><code class="language-mermaid">graph TD

  1[Docker] --&gt; 0[Container]
  00[Container]
  2[Local 端的 Daemon] --&gt; 1
  3[Docker CLI] -..-&gt; 2
  4[Kubernetes 端的 Daemon] --&gt; 12[Docker]
  12 --&gt; 00
  3 --&gt; 4

</code></pre>
<ol>
<li>先查看現有 Docker process list：<code>docker ps</code></li>
<li>再套用 minikube 的 Docker daemon <code>eval $(minikube -p minikube docker-env)</code></li>
</ol>
<pre><code class="language-bash=">$ minikube -p minikube docker-env
export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.64.2:2376&quot;
export DOCKER_CERT_PATH=&quot;/Users/evan.lu/.minikube/certs&quot;
export MINIKUBE_ACTIVE_DOCKERD=&quot;minikube&quot;

# To point your shell to minikube's docker-daemon, run:
# eval $(minikube -p minikube docker-env)
</code></pre>
<ol start="3">
<li>再一次呼叫 <code>docker ps</code></li>
</ol>
<pre><code class="language-bash=">$ docker ps
CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS          PORTS                                                                      NAMES
c3a17f71f9f9   435df390f367           &quot;/usr/bin/dumb-init …&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_controller_ingress-nginx-controller-5d88495688-ljjlx_ingress-nginx_44335178-30e5-4dc5-a481-7980627f281d_1
825f8d008c8f   86262685d9ab           &quot;/metrics-sidecar&quot;       35 minutes ago   Up 35 minutes                                                                              k8s_dashboard-metrics-scraper_dashboard-metrics-scraper-f6647bd8c-zbbkd_kubernetes-dashboard_13929488-084b-407c-9339-1b6b7b7feb2d_1
8258d336d0d1   6e38f40d628d           &quot;/storage-provisioner&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_storage-provisioner_storage-provisioner_kube-system_182b3e9c-2cd2-429f-aa0f-3103f916f32a_2
9edd75250040   9a07b5b4bfac           &quot;/dashboard --insecu…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_kubernetes-dashboard_kubernetes-dashboard-968bcb79-4l99k_kubernetes-dashboard_5cfcc5ce-7fb2-4304-baa1-6bf491e71469_1
c53e01b79ee7   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp   k8s_POD_ingress-nginx-controller-5d88495688-ljjlx_ingress-nginx_44335178-30e5-4dc5-a481-7980627f281d_1
72d0bf46751a   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_storage-provisioner_kube-system_182b3e9c-2cd2-429f-aa0f-3103f916f32a_1
b5ef7f9450a2   43154ddb57a8           &quot;/usr/local/bin/kube…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_kube-proxy_kube-proxy-vslx5_kube-system_e9319a11-d048-41ed-8cb1-92a0a17d67b5_1
0cb200215df8   bfe3a36ebd25           &quot;/coredns -conf /etc…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_coredns_coredns-74ff55c5b-sq5jt_kube-system_8f238e64-e20d-4899-8a46-96d783fa8250_1
7ffd1a33f25c   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_dashboard-metrics-scraper-f6647bd8c-zbbkd_kubernetes-dashboard_13929488-084b-407c-9339-1b6b7b7feb2d_1
b589a1d27625   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_kubernetes-dashboard-968bcb79-4l99k_kubernetes-dashboard_5cfcc5ce-7fb2-4304-baa1-6bf491e71469_1
809d46696a2e   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_kube-proxy-vslx5_kube-system_e9319a11-d048-41ed-8cb1-92a0a17d67b5_1
a6e5be9a3bb9   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_coredns-74ff55c5b-sq5jt_kube-system_8f238e64-e20d-4899-8a46-96d783fa8250_1
41d81fb8bbd9   0369cf4303ff           &quot;etcd --advertise-cl…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_etcd_etcd-minikube_kube-system_cf26ec9554c6f440822285b6ff9668f3_1
c7a6eca2d3f9   ed2c44fbdd78           &quot;kube-scheduler --au…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_kube-scheduler_kube-scheduler-minikube_kube-system_6b4a0ee8b3d15a1c2e47c15d32e6eb0d_1
3e9a5a9df7da   a27166429d98           &quot;kube-controller-man…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_kube-controller-manager_kube-controller-manager-minikube_kube-system_474c55dfb64741cc485e46b6bb9f2dc0_1
dcbf747b8975   a8c2fdb8bf76           &quot;kube-apiserver --ad…&quot;   35 minutes ago   Up 35 minutes                                                                              k8s_kube-apiserver_kube-apiserver-minikube_kube-system_0a7845e36bfd593e2ff9a027038089d3_1
ac54b241757d   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_kube-scheduler-minikube_kube-system_6b4a0ee8b3d15a1c2e47c15d32e6eb0d_1
6a91f7f8e57c   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_kube-controller-manager-minikube_kube-system_474c55dfb64741cc485e46b6bb9f2dc0_1
495996cf491c   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_kube-apiserver-minikube_kube-system_0a7845e36bfd593e2ff9a027038089d3_1
6ea9c36a7ff8   k8s.gcr.io/pause:3.2   &quot;/pause&quot;                 35 minutes ago   Up 35 minutes                                                                              k8s_POD_etcd-minikube_kube-system_cf26ec9554c6f440822285b6ff9668f3_1
</code></pre>
<h3 id="dashboard"><a class="header" href="#dashboard">Dashboard</a></h3>
<p>有一個 UI 介面會讓你對 Kubernetes 更了解</p>
<pre><code class="language-bash=">$ minikube dashboard
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
🎉  Opening http://127.0.0.1:56616/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser...
</code></pre>
<blockquote>
<p>minikube 很適合用來做 local 端測試或教學，但是對於線上環境，仍建議直接安裝 Kubernetes。</p>
</blockquote>
<h2 id="部署應用程式"><a class="header" href="#部署應用程式">部署應用程式</a></h2>
<p>目標：</p>
<pre><code>     ┌────┐   ┌────┐   ┌─────────┐   ┌────┐  ┌────────────┐
     │    │   │    ├───► Web Pod ├───►    ├──► Recipe Pod │
     │    │   │    │   └─────────┘   │ R  │  └────────────┘
     │    │   │    │                 │ e  │
     │    │   │ W  │                 │ c  │  ┌────────────┐
     │ I  │   │ e  │                 │ i  ├──► Recipe Pod │
R    │ n  │   │ b  │                 │ p  │  └────────────┘
e    │ g  │   │    │                 │ e  │
q    │ r  │   │ S  │   ┌─────────┐   │    │  ┌────────────┐
u────► e  ├───► e  ├───► Web Pod ├───► S  ├──► Recipe Pod │
e    │ s  │   │ r  │   └─────────┘   │ e  │  └────────────┘
s    │ s  │   │ v  │                 │ r  │
t    │    │   │ i  │                 │ v  │  ┌────────────┐
     │    │   │ c  │                 │ i  ├──► Recipe Pod │
     │    │   │ e  │                 │ c  │  └────────────┘
     │    │   │    │                 │ e  │
     │    │   │    │   ┌─────────┐   │    │  ┌────────────┐
     │    │   │    ├───► Web Pod ├───►    ├──► Recipe Pod │
     └────┘   └────┘   └─────────┘   └────┘  └────────────┘
</code></pre>
<p>開始部署應用程式之前，先把應用程式用 image 包裝好。</p>
<h3 id="應用程式"><a class="header" href="#應用程式">應用程式</a></h3>
<p>必須使用 minikube 的 Docker 建置 image。</p>
<pre><code class="language-bash=">$ eval $(minikube -p minikube docker-env)
$ docker build . -t recipe-api:latest
</code></pre>
<h3 id="部署"><a class="header" href="#部署">部署</a></h3>
<p>分別部署應用程式和 Service</p>
<h4 id="應用程式-1"><a class="header" href="#應用程式-1">應用程式</a></h4>
<pre><code>     ******   ******   ┌─────────┐   ******  ┌─────────┐
     *    *   *    *───►   Web   ├───►    *──► Recipe  │
     *    *   *    *   └─────────┘   * R  *  └─────────┘
     *    *   *    *                 * e  *
     *    *   * W  *                 * c  *  ┌─────────┐
     * I  *   * e  *                 * i  *──► Recipe  │
R    * n  *   * b  *                 * p  *  └─────────┘
e    * g  *   *    *                 * e  *
q    * r  *   * S  *   ┌─────────┐   *    *  ┌─────────┐
u────* e  *───► e  *───►   Web   ├───► S  *──► Recipe  │
e    * s  *   * r  *   └─────────┘   * e  *  └─────────┘
s    * s  *   * v  *                 * r  *
t    *    *   * i  *                 * v  *  ┌─────────┐
     *    *   * c  *                 * i  *──► Recipe  │
     *    *   * e  *                 * c  *  └─────────┘
     *    *   *    *                 * e  *
     *    *   *    *   ┌─────────┐   *    *  ┌─────────┐
     *    *   *    *───►   Web   ├───►    *──► Recipe  │
     ******   ******   └─────────┘   ******  └─────────┘
</code></pre>
<p>使用設定檔來部署應用程式。</p>
<blockquote>
<p>這裡不細講設定檔各行意義，僅概述。
<a href="https://github.com/evan361425/distributed-node/blob/master/minikube/web-deployment.yml">web-deployment</a>、<a href="https://github.com/evan361425/distributed-node/blob/master/minikube/recipe-deployment.yml">recipe-deployment</a></p>
</blockquote>
<ul>
<li>定義 Pod 和 Label</li>
<li>透過 Selector 決定 scaling 要使用哪一些 Pod</li>
<li>要求達到的狀態。以此設定檔為例：長到 3/5 個 Pods</li>
<li>Container 設定。版本、port 和 health-check</li>
</ul>
<p>套用至 minikube：</p>
<pre><code class="language-bash=">$ kubectl apply -f minikube/recipe-deployment.yml
</code></pre>
<p>這時可以看看是否都啟動成功</p>
<pre><code class="language-bash=">$ kubectl get deployment
NAME         READY   UP-TO-DATE   AVAILABLE   AGE
recipe-api   5/5     5            5           19h
web-api      3/3     3            3           18h
</code></pre>
<h4 id="service-1"><a class="header" href="#service-1">Service</a></h4>
<pre><code>     ┌────┐   ┌────┐   ***********   ┌────┐  ***********
     │    │   │    ├───►   Web   *───►    ├──► Recipe  *
     │    │   │    │   ***********   │ R  │  ***********
     │    │   │    │                 │ e  │
     │    │   │ W  │                 │ c  │  ***********
     │ I  │   │ e  │                 │ i  ├──► Recipe  *
R    │ n  │   │ b  │                 │ p  │  ***********
e    │ g  │   │    │                 │ e  │
q    │ r  │   │ S  │   ***********   │    │  ***********
u────► e  ├───► e  ├───►   Web   *───► S  ├──► Recipe  *
e    │ s  │   │ r  │   ***********   │ e  │  ***********
s    │ s  │   │ v  │                 │ r  │
t    │    │   │ i  │                 │ v  │  ***********
     │    │   │ c  │                 │ i  ├──► Recipe  *
     │    │   │ e  │                 │ c  │  ***********
     │    │   │    │                 │ e  │
     │    │   │    │   ***********   │    │  ***********
     │    │   │    ├───►   Web   *───►    ├──► Recipe  *
     └────┘   └────┘   ***********   └────┘  ***********
</code></pre>
<p>使用設定檔來部署 Service。</p>
<blockquote>
<p>在 web-service 中一同設定 Ingress。
<a href="https://github.com/evan361425/distributed-node/blob/master/minikube/web-service.yml">web-service</a>、<a href="https://github.com/evan361425/distributed-node/blob/master/minikube/recipe-service.yml">recipe-service</a></p>
</blockquote>
<ul>
<li>定義應用程式對外的 port（Node 外、Cluster 內）</li>
<li>設定 Ingress 導引條件，放如 <code>host1</code> 引到 <code>Service A</code> 或 <code>/api/v1</code> 引到 <code>Service B</code></li>
</ul>
<p>套用至 minikube：</p>
<pre><code class="language-bash=">$ kubectl apply -f minikube/recipe-service.yml
</code></pre>
<h3 id="測試"><a class="header" href="#測試">測試</a></h3>
<p>取得 Cluster Ingress address</p>
<pre><code class="language-bash=">$ kubectl get ingress
</code></pre>
<pre><code>NAME              CLASS    HOSTS         ADDRESS        PORTS   AGE
web-api-ingress   &lt;none&gt;   example.org   192.168.64.2   80      96s
</code></pre>
<pre><code class="language-bash=">$ curl -H &quot;Host: example.org&quot; http://192.168.64.2
</code></pre>
<h2 id="核心價值"><a class="header" href="#核心價值">核心價值</a></h2>
<p>上述範例可以透過 docker-compose 達成，但是 Kubernetes 不僅如此。</p>
<h3 id="版本"><a class="header" href="#版本">版本</a></h3>
<p>當有新版本的應用程式需要部署時，Kubernetes 會先把新版本的 Pod 啟起來，等舊版本的 Pod 處理完請求時，取代之。</p>
<p>先把設定檔 <code>web-deployment.yml</code> 對 Container 的版本調整至 <code>v2</code>，再套用新的設定檔到 minikube。</p>
<blockquote>
<p><code>--record=true</code> 可以記錄本次指令到 revision，幫助未來退版確認版本</p>
</blockquote>
<pre><code class="language-bash=">$ kubectl apply -f minikube/web-deployment.yml --record=true
</code></pre>
<blockquote>
<p>Kubernetes 足夠聰明去判斷你改動了哪裡，然後作出調整。</p>
</blockquote>
<p>現在來看看部署的過程吧。</p>
<blockquote>
<p><code>-w</code> 可以用來監控狀況，<code>-l</code> 篩選特定 label 的 Pod</p>
</blockquote>
<pre><code class="language-bash=">$ kubectl get pods -w -l app=web-api
NAME                       READY   STATUS              RESTARTS   AGE
web-api-769dc9c8b7-5824q   1/1     Running             0          19h
web-api-769dc9c8b7-6x9bc   1/1     Terminating         0          19h
web-api-769dc9c8b7-hk2dp   1/1     Running             0          19h
web-api-d85b66d56-pkrv5    1/1     Running             0          3s
web-api-d85b66d56-bgw55    1/1     Running             0          2s
web-api-769dc9c8b7-hk2dp   1/1     Terminating         0          19h
web-api-d85b66d56-6qsp4    0/1     Pending             0          0s
web-api-d85b66d56-6qsp4    0/1     ContainerCreating   0          0s
web-api-d85b66d56-6qsp4    1/1     Running             0          2s
web-api-769dc9c8b7-5824q   1/1     Terminating         0          19h
</code></pre>
<p>時相圖說明實際運作的狀況：</p>
<pre><code>┌────┐      ┌────┐ ┌────┐      ┌────┐ ┌────┐      ┌────┐
│v1-a│      │v1-a│ │v2-a│      │v1-a│ │v2-a│      │v2-a│
└────┘      └────┘ └────┘      └────┘ └────┘      └────┘

┌────┐      ┌────┐ ┌────┐      ┌────┐ ┌────┐      ┌────┐
│v1-b│ ───► │v1-b│ │v2-b│ ───► │v1-c│ │v2-b│ ───► │v2-b│
└────┘      └────┘ └────┘      └────┘ └────┘      └────┘
                             Terminating
┌────┐      ┌────┐ Container          ┌────┐      ┌────┐
│v1-c│      │v1-c│ Creating           │v2-c│      │v2-c│
└────┘      └────┘                    └────┘      └────┘
Running     Running                   Running     Running
</code></pre>
<p>你也可以看看有過哪些資源。</p>
<pre><code class="language-bash=">$ kubectl get rs -l app=web-api
NAME                 DESIRED   CURRENT   READY   AGE
web-api-769dc9c8b7   0         0         0       20h
web-api-d85b66d56    3         3         3       6m34s
</code></pre>
<p>退版時，先確認版本號碼：</p>
<pre><code class="language-bash=">$ kubectl rollout history deployment.v1.apps/web-api
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         kubectl apply --filename=web-api-deployment.yml --record=true
</code></pre>
<p>退版：</p>
<pre><code class="language-bash=">$ kubectl rollout undo deployment.v1.apps/web-api \
  --to-revision=1
</code></pre>
<h3 id="scaling"><a class="header" href="#scaling">Scaling</a></h3>
<p>手動增長到十個</p>
<pre><code class="language-bash=">$ kubectl scale deployment.apps/recipe-api --replicas=10
deployment.apps/recipe-api scaled
$ kubectl get deployment
NAME         READY   UP-TO-DATE   AVAILABLE   AGE
recipe-api   5/10    10           5           1m
web-api      3/3     3            3           1m
</code></pre>
<blockquote>
<p>除了透過指令增減 Pod 數量，也可以改動 Deployment 檔，再引入。</p>
</blockquote>
<p>在 scaling 的過程中，Kubernetes 會確定可以被引用才引用，移除時亦同。</p>
<blockquote>
<p>這裡的 scaling 是動態調整的，而 docker-compose 是當初設定的數量後做啟動，並非 scaling。</p>
</blockquote>
<p>除了手動增長減少，Kubernetes 也可以自動化：</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">Horizontal Autoscaler</a> 透過 CPU 或其他系統資源去增減 Pod。</li>
<li>Cron Job 透過排程去增減 Pod。</li>
</ul>
<blockquote>
<p>Kubernetes 還有很多功能，我自己也才剛開始摸索，希望未來有人能深入瞭解並和大家分享！</p>
</blockquote>
<h2 id="misc"><a class="header" href="#misc">Misc.</a></h2>
<ul>
<li>Live migration</li>
<li>Retry strategy</li>
<li>Chaos resiliency</li>
<li>Data atomicity</li>
<li>Dependency security</li>
<li>Dependency upgrade</li>
</ul>
<blockquote>
<p>上述這些在本書中都有討論到，個人覺得也很有趣，有興趣的人都可以看看。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>這裡是隨筆，各種紀錄東西</p>
<p>系統架構類：</p>
<ul>
<li><a href="essay/made-container.html">如何製作 Docker Container</a></li>
<li><a href="essay/pki-checklist.html">建置 PKI 注意事項</a></li>
</ul>
<p>網路相關：</p>
<ul>
<li><a href="essay/retry-strategy.html">Retry 的策略</a></li>
<li><a href="essay/url-structure.html">URL 長什麼樣子</a></li>
</ul>
<p>程式語言類：</p>
<ul>
<li><a href="essay/node.js-best-practice.html">Node.js 最佳實作</a>)</li>
<li><a href="essay/node.js-error.html">Node.js 的錯誤有哪些</a></li>
</ul>
<p>企劃類：</p>
<ul>
<li><a href="essay/questionnaire-principal.html">問卷設計指南</a></li>
</ul>
<p>其他：</p>
<ul>
<li><a href="essay/vault/index.html">Vault</a></li>
<li><a href="essay/web-security/index.html">網路安全</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>建立 container 前，需要先建立 image，然而這步驟會和應用程式的需求而有很大的不同，在此謹概略介紹以 Node.js 為背景的應用程式。</p>
<p>製作 image 分為三個步驟：</p>
<ol>
<li>準備好應用程式的相依套件</li>
<li>準備好執行應用程式的環境</li>
<li>執行應用程式</li>
</ol>
<h2 id="準備好應用程式的相依套件"><a class="header" href="#準備好應用程式的相依套件">準備好應用程式的相依套件</a></h2>
<p>以 Node.js 為例，則是 <code>npm i</code> 或更精簡的 <code>npm ci --only=production</code>。
其他如：</p>
<ul>
<li>PHP 的 <code>composer install --no-dev --optimize-autoloader</code></li>
<li>Python 的 <code>pip install</code></li>
<li>Gradle 的 <code>bundle install --clean --without dev</code></li>
</ul>
<p>Dockerfile 是 Docker 用來建立 image 的指令表，類似 Makefile。
以下為 Node.js 建立相依套件的指令表：</p>
<pre><code class="language-dockerfile=">FROM node:lts-alpine AS deps

# Change current folder to /srv
WORKDIR /srv
COPY package*.json ./
RUN npm ci --only=production
</code></pre>
<p>上述每一行都代表一個 Layer，而每一次呼叫 <code>FROM</code>，即代表建立一組 Stage。</p>
<blockquote>
<p>在 Docker 的 Best Practice 中會建議使用越少 command 越好就是避免過大的 layer</p>
</blockquote>
<h2 id="準備好執行應用程式的環境"><a class="header" href="#準備好執行應用程式的環境">準備好執行應用程式的環境</a></h2>
<p>在執行環境中，不需要一些 Node.js 的特定功能，如 <code>npm</code>。</p>
<pre><code class="language-dockerfile=">FROM node:lts-slim AS release
</code></pre>
<p>除此之外也可以在 Alpine 環境下建立極簡的 Node.js，詳見<a href="https://github.com/evan361425/distributed-node/blob/master/Dockerfile-web">實作的程式碼</a>。</p>
<blockquote>
<p>概念就是下載 <code>curl</code>（Alpine 無 <code>curl</code>）再下載 Node.js 後刪除不必要檔案</p>
</blockquote>
<blockquote>
<p>更完整內容詳見 Node.js 提供的建立 image 的<a href="https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md">最佳做法指引</a></p>
</blockquote>
<p>再來就剩把剛剛在 <code>deps</code> 環境中建立的相依套件拉過來：</p>
<pre><code class="language-dockerfile=">COPY --from=deps /srv/node_modules ./node_modules
COPY . .
</code></pre>
<p>警告：<code>COPY . .</code>代表會把現在本地端資料夾中的所有檔案複製此 image 中。
為了避免不必要檔案被複製，可於 <code>.dockerignore</code> 中設定</p>
<p>.dockerignore 範例：</p>
<pre><code>node_modules
npm-debug.log
Dockerfile
.git
.gitignore
.eslintrc
</code></pre>
<h2 id="執行應用程式"><a class="header" href="#執行應用程式">執行應用程式</a></h2>
<p>再來就剩準備設定檔和執行程式了：</p>
<pre><code class="language-dockerfile=">EXPOSE 1337
ENV HOST 0.0.0.0
ENV PORT 1337
CMD [ &quot;node&quot;, &quot;server.js&quot;
</code></pre>
<h2 id="包裝成-container"><a class="header" href="#包裝成-container">包裝成 Container</a></h2>
<pre><code class="language-bash=">docker build -t example/server:v0.0.1 .
</code></pre>
<p>這時就可以看到各個 layer 被執行的過程。</p>
<pre><code>Sending build context to Docker daemon  155.6kB
Step 1/11 : FROM node:lts-alpine AS deps
 ---&gt; 532fd65ecacd
... TRUNCATED ...
Step 11/11 : CMD [ &quot;node&quot;, &quot;server.js&quot; ]
 ---&gt; Running in d7bde6cfc4dc
Removing intermediate container d7bde6cfc4dc
 ---&gt; a99750d85d81
Successfully built a99750d85d81
</code></pre>
<h2 id="更新"><a class="header" href="#更新">更新</a></h2>
<p>Docker Image 在建立時，會透過 SHA 值進行暫存，所以當有部分改動的時候就不需要全部重新建立。</p>
<blockquote>
<p>SHA 值計算方式是上一個 SHA 值加上現行的指令組出來的。</p>
</blockquote>
<p>也就是說，若改動的僅有應用程式的程式碼，如 <code>server.js</code>，在重建 image 時就僅需要執行 <code>COPY . .</code> 以後的代碼。</p>
<p>相對的，當 package.json 改變時（如 dependency 增加）就需要從 <code>deps</code> 這層 stage 開始建立起。</p>
<h3 id="範例-3"><a class="header" href="#範例-3">範例</a></h3>
<p>透過 <code>docker history example/server:v0.0.1</code> 可以觀看其建立時的記憶體用量。</p>
<ul>
<li><code>v0.0.1</code> 代表初始版本</li>
<li><code>v0.0.2</code> 代表修正 <code>server.js</code></li>
<li><code>v0.0.3</code> 代表新增套件</li>
</ul>
<table><thead><tr><th>Layer</th><th>Size</th><th>v0.0.1</th><th>v0.0.2</th><th>v0.0.3</th></tr></thead><tbody>
<tr><td>1: FROM node AS deps</td><td>N/A</td><td>532fd65ecacd</td><td>532fd65ecacd</td><td>532fd65ecacd</td></tr>
<tr><td>2: WORKDIR /srv</td><td>N/A</td><td>bec6e0fc4a96</td><td>bec6e0fc4a96</td><td>bec6e0fc4a96</td></tr>
<tr><td>3: COPY package*</td><td>N/A</td><td>58341ced6003</td><td>58341ced6003</td><td>959c7f2c693b</td></tr>
<tr><td>4: RUN npm ci</td><td>N/A</td><td>dd6cd3c5a283</td><td>dd6cd3c5a283</td><td>6e9065bacad0</td></tr>
<tr><td>5: FROM node:lts-slim AS release</td><td>5.6MB</td><td>e7d92cdc71fe</td><td>e7d92cdc71fe</td><td>e7d92cdc71fe</td></tr>
<tr><td>6: COPY node_modules</td><td>67.8MB</td><td>a86f6f94fc75</td><td>a86f6f94fc75</td><td>b97b002f4734</td></tr>
<tr><td>7: COPY . .</td><td>138kB</td><td>cab24763e869</td><td>7f6f49f5bc16</td><td>f2c9ac237a1c</td></tr>
<tr><td>8: EXPOSE</td><td>0</td><td>0efe3d9cd543</td><td>4fc6b68804c9</td><td>f4b64a1c5e64</td></tr>
<tr><td>9: ENV HOST</td><td>0</td><td>9104495370ba</td><td>df073bd1c682</td><td>fee5ff92855c</td></tr>
<tr><td>10: ENV PORT</td><td>0</td><td>04d6b8f0afce</td><td>f67d0897cb11</td><td>638a7ff0c240</td></tr>
<tr><td>11: CMD</td><td>0</td><td>b3babfadde8e</td><td>9b6514336e72</td><td>12d0c7e37935</td></tr>
<tr><td>Cost per Deploy</td><td>N/A</td><td>0</td><td>138kB</td><td>68MB</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="do-in-code"><a class="header" href="#do-in-code">Do In Code</a></h2>
<ol>
<li>Compression: proxy &gt; app.use(compression())</li>
<li>Asynchronous (async.) &gt;&gt; Synchronous (sync.) - The <strong>only</strong> reason to use sync. function is the time to start up server.
唯一有理由使用同步函數的時機是在最初啟動之時</li>
<li>Static files: proxy &gt; serve-static &gt; res.sendFile()</li>
<li>Console is sync! Always use async or use sync only in development.
<ul>
<li>Debugging: debug &gt;&gt; console</li>
<li>Application: Winston / Bunyan &gt;&gt; console</li>
</ul>
</li>
<li>Handle Error ( Important!, Detail in next section )
<ul>
<li>Try-catch</li>
<li>Promise</li>
</ul>
</li>
</ol>
<h2 id="handle-error"><a class="header" href="#handle-error">Handle Error</a></h2>
<ol>
<li>Try-catch is <strong>synchronous</strong>.</li>
<li>Express catch all sync. error in default (v.5 catch <em>Promise</em> as well)</li>
</ol>
<h3 id="what-will-log"><a class="header" href="#what-will-log">What will log?</a></h3>
<pre><code class="language-js">const callback = async () =&gt; {
  console.log(&quot;do another thing&quot;);
  throw new Error(&quot;foo&quot;);
  console.log(&quot;do more thing&quot;);
};

const method = async () =&gt; {
  console.log(&quot;do first thing&quot;);
  await callback();
  console.log(&quot;do second thing&quot;);
};

const main = async () =&gt; {
  try {
    await method();
  } catch (err) {
    console.log(&quot;fire try-catch!&quot;);
  }

  console.log(&quot;finish project!&quot;);
};
</code></pre>
<h4 id="result"><a class="header" href="#result">result:</a></h4>
<pre><code>do first  thing
do another thing
do second thing
finish project!
UnhandledPromiseRejectionWarning: Error: foo
... (error stack)
</code></pre>
<h4 id="why"><a class="header" href="#why">why?</a></h4>
<ol>
<li><code>callback</code> invoked some time later after <code>method</code> (<code>do another thing</code>)</li>
<li>happend exception! wait to finish other process</li>
<li>finish method (<code>do second thing</code>)</li>
<li>finish try-catch block</li>
<li>final run (<code>finish project!</code>)</li>
</ol>
<h3 id="category"><a class="header" href="#category">Category</a></h3>
<ol>
<li>Operational Errors
<ul>
<li>The errors you are/can except.</li>
<li>Log, Show, Retry/Abort.</li>
</ul>
</li>
<li>Programmer Errors
<ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors#fnref:1">The best way to recover from programmer errors is to crash immediately</a></li>
<li>Try debug your program rather than handle it.</li>
</ul>
</li>
</ol>
<h2 id="do-in-configuration"><a class="header" href="#do-in-configuration">Do In Configuration</a></h2>
<ol>
<li><code>env.NODE_ENV='production';</code></li>
<li>Rebuild after error, use <a href="http://strong-pm.io/compare/">helpers</a> or <em>init</em> system <a href="https://wiki.debian.org/systemd">[1]</a><a href="http://upstart.ubuntu.com/">[2]</a></li>
<li>Multi-threads [<a href="https://nodejs.org/docs/latest/api/cluster.html">1</a>][<a href="https://docs.strongloop.com/display/SLC/Clustering">2</a>]</li>
<li>Caching [<a href="https://www.varnish-cache.org/">Varnish</a>][<a href="https://serversforhackers.com/nginx-caching/">Nginx</a>]</li>
<li>Reverse-Proxy [<a href="https://serversforhackers.com/nginx-caching/">Nginx</a>][<a href="http://www.haproxy.org/">HAProxy</a>]</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="network"><a class="header" href="#network">Network</a></h2>
<table><thead><tr><th>Error</th><th>Context</th><th>Ambiguous</th><th>Meaning</th></tr></thead><tbody>
<tr><td>EACCES</td><td>Server</td><td>N/A</td><td>Cannot listen on port due to permissions</td></tr>
<tr><td>EADDRINUSE</td><td>Server</td><td>N/A</td><td>Cannot listen on port since another process has it</td></tr>
<tr><td>ECONNREFUSED</td><td>Client</td><td>No</td><td>Client unable to connect to server</td></tr>
<tr><td>ENOTFOUND</td><td>Client</td><td>No</td><td>DNS lookup for the server failed</td></tr>
<tr><td>ECONNRESET</td><td>Client</td><td>Yes</td><td>Server closed connection with client</td></tr>
<tr><td>EPIPE</td><td>Client</td><td>Yes</td><td>Connection to server has closed</td></tr>
<tr><td>ETIMEDOUT</td><td>Client</td><td>Yes</td><td>Server didn’t respond in time</td></tr>
</tbody></table>
<h2 id="process"><a class="header" href="#process">Process</a></h2>
<ul>
<li><code>EACCES</code> (Permission denied): An attempt was made to access a file in a way forbidden by its file access permissions.</li>
<li><code>EADDRINUSE</code> (Address already in use): An attempt to bind a server (<a href="https://nodejs.org/api/net.html"><code>net</code></a>, <a href="https://nodejs.org/api/http.html"><code>http</code></a>, or <a href="https://nodejs.org/api/https.html"><code>https</code></a>) to a local address failed due to another server on the local system already occupying that address.</li>
<li><code>EPERM</code> (Operation not permitted): An attempt was made to perform an operation that requires elevated privileges.</li>
</ul>
<h2 id="file-system"><a class="header" href="#file-system">File System</a></h2>
<ul>
<li><code>EEXIST</code> (File exists): An existing file was the target of an operation that required that the target not exist.</li>
<li><code>EISDIR</code> (Is a directory): An operation expected a file, but the given pathname was a directory.</li>
<li><code>EMFILE</code> (Too many open files in system): Maximum number of <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptors</a> allowable on the system has been reached, and requests for another descriptor cannot be fulfilled until at least one has been closed. This is encountered when opening many files at once in parallel, especially on systems (in particular, macOS) where there is a low file descriptor limit for processes. To remedy a low limit, run <code>ulimit -n 2048</code> in the same shell that will run the Node.js process.</li>
<li><code>ENOENT</code> (No such file or directory): Commonly raised by <a href="https://nodejs.org/api/fs.html"><code>fs</code></a> operations to indicate that a component of the specified pathname does not exist. No entity (file or directory) could be found by the given path.</li>
<li><code>ENOTDIR</code> (Not a directory): A component of the given pathname existed, but was not a directory as expected. Commonly raised by <a href="https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback"><code>fs.readdir</code></a>.</li>
<li><code>ENOTEMPTY</code> (Directory not empty): A directory with entries was the target of an operation that requires an empty directory, usually <a href="https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback"><code>fs.unlink</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>本資料來源於 <a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-32.pdf">NIST 800-32 Ct.3</a></p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc4158.html#page-14">Certification Path Building</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6489">Key Rollover in the Resource Public Key Infrastructure</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5280#section-6.1">X.509</a></li>
</ul>
<pre><code>
 ┌─────────────────────────────────────────────┐
 │                   IDC                       │
 │                      ┌────────┐             │
 │                      │  Root  │             │
 │                      └────▲───┘             │
 │                           │                 │
 │                      HTTP │                 │
 │                           │                 │
 │      HTTP          ┌──────▼─────┐           │
 │  ┌─────────────────►            │           │
 │  │                 │Intermediate│           │
 │  │            ┌────►            ◄────┐      │
 │  │       HTTP │    └──────▲─────┘    │      │
 │  │            │           │          │      │
 │  │         ┌──▼───┐     ┌─▼────┐   ┌─▼────┐ │
 │  │      ┌──► AES  ◄───┐ │  EE  │   │  EE  │ │
 │  │      │  └─▲────┘   │ └──────┘   └──────┘ │
 │  │ HTTPS│    │        │                     │
 │  │      │    └────┐   └─────┐               │
 │  │      │         │         │               │
 │  │   ┌──┴──┐ ┌────┴────┐ ┌──┴──┐            │
 │  └───┤ API │ │ Service │ │ APP │            │
 │      └─────┘ └─────────┘ └─────┘            │
 │                                             │
 └─────────────────────────────────────────────┘
</code></pre>
<p>可能需要溝通的原因：</p>
<ul>
<li>初始註冊/認證</li>
<li>金鑰對更新</li>
<li>憑證更新</li>
</ul>
<h2 id="nist"><a class="header" href="#nist">NIST</a></h2>
<h3 id="名詞介紹"><a class="header" href="#名詞介紹">名詞介紹</a></h3>
<ul>
<li>CA 簽署簽證給 user，此時 CA 是 issuer。</li>
<li>CA 會把驗證 user 的資訊丟給 Registration Authority(RA)，例如：DNS</li>
<li>使用 CA 簽出來的簽證，並以此來信任 user 的第三方稱為 relying parties</li>
</ul>
<p><em>certificate policy</em> 定義簽證的政策，例如該用什麼金鑰種類、長度。能做到檢查的步驟，實務上僅有簽發時作檢查，然後再把資訊放在簽證上。</p>
<blockquote>
<p>correctly configuring root certificate stores is a critical step in key management.</p>
</blockquote>
<p><strong>X.509</strong> 會放</p>
<ul>
<li>user name</li>
<li>issuer name</li>
<li>public key</li>
<li>signature</li>
<li>validity (starting and expiring times)</li>
<li>cryptographic algorithm(s)</li>
<li>和其他 Private 的 extension</li>
</ul>
<p>驗證過程</p>
<ul>
<li>Cross certificates，就算是 root CA(<em>trust anchors</em>)也可能會需要其他同樣是 root CA 的簽證。</li>
<li>certification path，relying party 從 user 到 trust anchors 的驗證流程</li>
</ul>
<p>驗證過程中的每一段都需要確認（path validation）：</p>
<ul>
<li>簽證驗證</li>
<li>簽證沒被撤銷</li>
<li>被正確的政策 issue</li>
</ul>
<p>簽證的狀態展示（簽證沒被撤銷）方式有兩種：</p>
<ul>
<li>Online Certificate Status Protocol (OCSP)</li>
<li>certificate revocation list, or CRL</li>
</ul>
<p>若一開始是使用 <strong>key establishment</strong> 做簽證，要可以做金鑰的回復。</p>
<h3 id="procurement-guidance"><a class="header" href="#procurement-guidance">Procurement Guidance</a></h3>
<p>挑選 CA 產品的 check list。</p>
<h4 id="cara-software-and-hardware"><a class="header" href="#cara-software-and-hardware">CA/RA Software and Hardware:</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
確保支援任一協定：
<ul>
<li>Certificate Management Protocol (CMP) <a href="https://datatracker.ietf.org/doc/html/rfc4210">RFC 4210</a></li>
<li>Enrollment over Secure Transport (EST) <a href="https://datatracker.ietf.org/doc/html/rfc7030">RFC 7030</a></li>
<li>Certificate Management Using Cryptographic Message Syntax (CMC) <a href="https://datatracker.ietf.org/doc/html/rfc5272">RFC 5272</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
確保可以產生憑證，其中應含有的資訊於後討論之。</li>
<li><input disabled="" type="checkbox"/>
可以產生多組憑證，且允許特定金鑰種類。</li>
<li><input disabled="" type="checkbox"/>
允許 CRL。</li>
<li><input disabled="" type="checkbox"/>
允許外部連結 CRL，且必須含有 HTTP URLS。</li>
<li><input disabled="" type="checkbox"/>
應可以透過 LDPA 取得 CRL。</li>
<li><input disabled="" type="checkbox"/>
允許 OCSP。</li>
<li><input disabled="" type="checkbox"/>
每組 PKI 都有其憑證資訊，且資訊能被顯示於其簽署的簽證 CRL。</li>
<li><input disabled="" type="checkbox"/>
允許設定客制相關資訊於憑證中。</li>
<li><input disabled="" type="checkbox"/>
允許使用 RSA 和 ECDSA 演算法。</li>
<li><input disabled="" type="checkbox"/>
可以備份並災難復原。</li>
<li><input disabled="" type="checkbox"/>
允許權限在帳號之間的轉移。</li>
</ul>
<h4 id="ocsp-responders"><a class="header" href="#ocsp-responders">OCSP Responders:</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
確保 OCSP responders 符合 <a href="https://datatracker.ietf.org/doc/html/rfc6960">RFC 6960</a> <em>Online Certificate Status Protocol</em>。</li>
<li><input disabled="" type="checkbox"/>
確保能處理有無簽章和名稱的請求，就算是拒絕也須回應。</li>
<li><input disabled="" type="checkbox"/>
回應時沒有任何於 <a href="https://datatracker.ietf.org/doc/html/rfc5019">RFC 5019</a> 中提及的錯誤</li>
<li><input disabled="" type="checkbox"/>
回應時的簽章建議符合和其產生的憑證的演算法相同，金鑰格式也建議一樣。允許使用 RSA 和 ECDSA 演算法。</li>
</ul>
<h4 id="加密模組"><a class="header" href="#加密模組">加密模組</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
CAs、Key Recovery Servers 和 OCSP responders 高於 <a href="https://csrc.nist.gov/publications/detail/fips/140/2/final">FIPS 140-2</a> 等級 3。</li>
<li><input disabled="" type="checkbox"/>
RAs 需高於 FIPS 140-2 等級 2。</li>
<li><input disabled="" type="checkbox"/>
確保請求簽證的單位和使用者的加密模組高於 FIPS 140-2 等級 1。</li>
</ul>
<h4 id="key-recovery-servers"><a class="header" href="#key-recovery-servers">Key Recovery Servers</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
如果 PKI 支援金鑰產生，就應支援金鑰救援服務。</li>
<li><input disabled="" type="checkbox"/>
應支援自動化的金鑰救援服務。</li>
</ul>
<h4 id="relying-party-software"><a class="header" href="#relying-party-software">Relying Party Software</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
路程驗證（path validation）
<ul>
<li><input disabled="" type="checkbox"/>
確保符合 <a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC 5280</a> <em>conformant path validation</em>。</li>
<li><input disabled="" type="checkbox"/>
允許組織外的驗證（例如透過 federal agency）且需符合 <a href="https://csrc.nist.gov/projects/pki-testing/">NIST 建議的驗證方式</a>。</li>
<li><input disabled="" type="checkbox"/>
允許有 Bridge 的路徑，且需符合 <a href="https://csrc.nist.gov/projects/pki-testing/">NIST 建議的驗證方式</a>。</li>
<li><input disabled="" type="checkbox"/>
應該同時支援 CRLs 和 OCSP。</li>
</ul>
</li>
<li>驗證憑證
<ul>
<li><input disabled="" type="checkbox"/>
確保可以建立驗證的路徑</li>
<li><input disabled="" type="checkbox"/>
至少要能處理 HTTP-based 的回應</li>
<li><input disabled="" type="checkbox"/>
應要能處理 LDAP 的協定</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
作用於企業端 PKI 的 RP 應能發現路徑上受 trust anchor CA 認證的階層式 CA。</li>
<li><input disabled="" type="checkbox"/>
非企業端 PKI 的 RP 應能發現路徑上非階層式的 CA。</li>
</ul>
<h4 id="client-software"><a class="header" href="#client-software">Client Software</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
客戶端允許多個公私鑰請求多個簽證</li>
<li><input disabled="" type="checkbox"/>
加密模組高於 FIPS 140-2 等級 1</li>
<li><input disabled="" type="checkbox"/>
客戶應可使用 CA 提供的 certificate management protocol</li>
</ul>
<h3 id="給-pki-管理者的建議"><a class="header" href="#給-pki-管理者的建議">給 PKI 管理者的建議</a></h3>
<p>管理者應確保使用端的人接受必要訓練和公司安全政策被執行。</p>
<h4 id="certificate-issuance"><a class="header" href="#certificate-issuance">Certificate Issuance</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
確保 CAs 設定好可接受的公私鑰演算法和金鑰長度，還有驗證 domain</li>
<li><input disabled="" type="checkbox"/>
為了最大化標準性，應使用 RSA 去做簽章和金鑰轉移</li>
<li><input disabled="" type="checkbox"/>
為了最大化安全性和效率，應使用 EC 去做簽章和金鑰轉移</li>
<li><input disabled="" type="checkbox"/>
當簽發簽證或 CRLs 時，應符合演算法、長度的規範</li>
<li><input disabled="" type="checkbox"/>
利用 subject key 產生 signing key 時，簽證的安全性應大於 subject key 去簽證</li>
<li>產生金鑰時：
<ul>
<li><input disabled="" type="checkbox"/>
使用者應產生屬於他們自己的簽證金鑰</li>
<li><input disabled="" type="checkbox"/>
若上 PKI 透過金鑰傳送方式去傳送金鑰，應提供金鑰復原服務</li>
<li><input disabled="" type="checkbox"/>
CAs 要確保金鑰真的屬於使用者（PoP）</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
應在簽證前先驗證金鑰</li>
<li>Key usage extension
<ul>
<li><input disabled="" type="checkbox"/>
簽證應包含 key-ussage extension</li>
<li><input disabled="" type="checkbox"/>
key-ussage extension 應限制一種獲取方式，使用者自己產生或 PKI 產生</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
所有簽證應包含 CRLs 的位置資訊</li>
<li><input disabled="" type="checkbox"/>
若提供 OCSP responder，應提供位置資訊於簽證中</li>
<li><input disabled="" type="checkbox"/>
在過期前應重新簽署完成，並且正確更新憑證資訊，如 domain 或信箱</li>
</ul>
<h4 id="certificate-revocation-requests"><a class="header" href="#certificate-revocation-requests">Certificate Revocation Requests</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
應提供自動撤銷機制：
<ul>
<li><input disabled="" type="checkbox"/>
CAs 應在撤銷時進行身份驗證</li>
<li><input disabled="" type="checkbox"/>
使用者提供身份證明並要求撤銷時，應在不需人力介入下執行。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
RAs 應能在設定後，代表使用者或公司請求簽證撤銷</li>
</ul>
<h4 id="certificate-revocation-list-generation"><a class="header" href="#certificate-revocation-list-generation">Certificate Revocation List Generation</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
為了最大標準化，CAs 應提供完整的撤銷簽證於 CRL 中</li>
<li><input disabled="" type="checkbox"/>
若有大量的撤銷簽證，可以產生部分的 CRL，但須額外提供完整的 CRL 位置資訊。一份 CRL 不應超過 250,000 的撤銷簽證。</li>
</ul>
<h4 id="pki-repositories-for-the-distribution-of-certificates-and-crls"><a class="header" href="#pki-repositories-for-the-distribution-of-certificates-and-crls">PKI Repositories for the Distribution of Certificates and CRLs</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
PKIs 應能公開提供簽證和 CRL</li>
<li><input disabled="" type="checkbox"/>
PKI 庫應能提供身份驗證後的簽證位置修改和 PKI 庫的 CRL 分佈</li>
<li><input disabled="" type="checkbox"/>
PKI 庫應至少允許 HTTP 1.1 或 LDAP version 3</li>
<li><input disabled="" type="checkbox"/>
為了最大標準化， HTTP 和 LDAP 都應被符合</li>
<li><input disabled="" type="checkbox"/>
HA 應被考慮</li>
<li><input disabled="" type="checkbox"/>
PKI 庫應包含所有其擁有的 PKI 的所有簽證</li>
<li><input disabled="" type="checkbox"/>
PKI 庫應包含所有其擁有的 PKI 的 CRL</li>
</ul>
<h4 id="ocsp-responders-1"><a class="header" href="#ocsp-responders-1">OCSP Responders</a></h4>
<p>For federal agencies, detailed configuration guidance for OCSP responders is specified in Draft Guidance for OCSP Responders in the U.S. Federal PKI.17</p>
<ul>
<li>為了最大標準化：
<ul>
<li><input disabled="" type="checkbox"/>
OCSP responders 不應要求請求要有簽名，且不能限制哪些簽證狀態是可以被允許的</li>
<li><input disabled="" type="checkbox"/>
應能回應基本的資訊，且不能含有危險的 extensions</li>
</ul>
</li>
<li>若僅需符合內部社群而非標準化：
<ul>
<li><input disabled="" type="checkbox"/>
OCSP responders 可要求請求要有簽名，且可拒絕外部的請求</li>
<li><input disabled="" type="checkbox"/>
OCSP 的回應訊息可能含有特殊的 extensions</li>
</ul>
</li>
</ul>
<h4 id="backup-and-archive"><a class="header" href="#backup-and-archive">Backup and Archive</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
應該備份資料，並當災難發生後能重新啟用</li>
<li><input disabled="" type="checkbox"/>
CAs 應紀錄何時和何人申請的簽證</li>
<li><input disabled="" type="checkbox"/>
應有 log 紀錄所有簽證和 CRL</li>
<li><input disabled="" type="checkbox"/>
申請人的公鑰應和其簽證一起被保存</li>
</ul>
<h4 id="relying-party-integration-and-configuration"><a class="header" href="#relying-party-integration-and-configuration">Relying Party Integration and Configuration</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
應可以發現路徑和獲得狀態資訊</li>
<li><input disabled="" type="checkbox"/>
應要可以支援 CRL 和 OCSP 的格式</li>
<li><input disabled="" type="checkbox"/>
應能分辨最小單位的 trust anchors</li>
<li><input disabled="" type="checkbox"/>
當情境處於「公司對政府」或「政府對政府」，應使用 Common Policy Root CA 或和 Common Policy Root CA 互相認證的 CA 或以 Federal Bridge 為 trust anchor 的 CA</li>
<li><input disabled="" type="checkbox"/>
當情境屬於「使用者對政府」，應用程式的安全性無法做到高度限制，為了達成高標準性，使用者可能會使用的預先安裝至 COTS products 的 trust anchors</li>
<li>路徑驗證：
<ul>
<li><input disabled="" type="checkbox"/>
對和使用者應用程式對接的連線，路徑驗證應被設定成可接受所有合法路徑</li>
<li><input disabled="" type="checkbox"/>
對需要高度安全性的系統，應被設定成僅接受特定適當的政策的路徑</li>
</ul>
</li>
</ul>
<h3 id="user-guidance-subscribers"><a class="header" href="#user-guidance-subscribers">User Guidance (Subscribers)</a></h3>
<p>對於和 PKI 申請權證的使用者：</p>
<ul>
<li><input disabled="" type="checkbox"/>
使用者應產生屬於自己的金鑰，用作簽證和身份證明</li>
<li><input disabled="" type="checkbox"/>
使用者可能自己產生金鑰，或從可信任的資源取得金鑰</li>
<li><input disabled="" type="checkbox"/>
使用者應包管好私鑰，包括加密私鑰的 PIN 碼或密碼</li>
<li><input disabled="" type="checkbox"/>
使用者應請求撤銷，當他覺得該模組被偷、複製或破壞</li>
<li>使用者應管理舊的金鑰，除非管理單位有另外政策說明：
<ul>
<li><input disabled="" type="checkbox"/>
當簽證過期就應把私鑰丟棄</li>
<li><input disabled="" type="checkbox"/>
<ol start="2">
<li>用來產生簽章的私鑰，應等到其產生的私鑰都被重新加密或捨棄後才能丟棄</li>
</ol>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="essay/questionnaire-principal.html#%E9%A1%8C%E9%A0%85%E8%A8%AD%E8%A8%88%E7%9A%84%E5%8E%9F%E5%89%87">題項設計的原則</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E5%B0%81%E9%96%89%E5%9E%8B%E9%81%B8%E9%A0%85%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87">封閉型選項設計原則</a></li>
<li><a href="essay/questionnaire-principal.html#%E5%90%88%E7%90%86%E7%9A%84%E9%81%B8%E9%A0%85%E6%95%B8%E9%87%8F">合理的選項數量</a></li>
<li><a href="essay/questionnaire-principal.html#%E7%9F%A9%E9%99%A3%E9%A1%8C">矩陣題</a></li>
<li><a href="essay/questionnaire-principal.html#%E6%9D%8E%E7%89%B9%E5%85%8B%E9%87%8F%E5%B0%BA">李特克量尺</a></li>
<li><a href="essay/questionnaire-principal.html#%E6%97%A2%E6%9C%89%E7%9A%84%E5%95%8F%E5%8D%B7%E9%A1%8C%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%8A%A0%E9%80%9F%E8%A3%BD%E4%BD%9C">既有的問卷題型可以加速製作</a></li>
<li><a href="essay/questionnaire-principal.html#%E5%95%8F%E9%A1%8C%E7%9A%84%E9%A1%9E%E5%9E%8B">問題的類型</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E6%8F%8F%E7%B9%AA%E5%87%BA%E7%9B%AE%E6%A8%99%E6%97%8F%E7%BE%A4%E9%95%B7%E7%9B%B8">描繪出目標族群長相</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%A1%8C%E7%82%BA%E6%85%8B%E5%BA%A6%E8%AA%8D%E7%9F%A5">行為、態度、認知</a></li>
<li><a href="essay/questionnaire-principal.html#net-promoter-score-nps">Net Promoter Score (NPS)</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E7%BC%BA%E9%BB%9E">缺點</a></li>
<li><a href="essay/questionnaire-principal.html#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E6%9C%8D%E5%8B%99%E6%BB%BF%E6%84%8F%E5%BA%A6">服務滿意度</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%B3%87%E5%AE%89">資安</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E5%95%8F%E5%8D%B7%E4%BD%88%E5%B1%80">問卷佈局</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E8%B5%B7">起</a></li>
<li><a href="essay/questionnaire-principal.html#%E6%89%BF">承</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%BD%89">轉</a></li>
<li><a href="essay/questionnaire-principal.html#%E5%90%88">合</a></li>
<li><a href="essay/questionnaire-principal.html#%E9%9C%80%E8%A6%81%E6%94%BE%E5%A4%9A%E5%B0%91%E9%A1%8C%E7%9B%AE">需要放多少題目</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E5%95%8F%E5%8D%B7%E5%B7%A5%E5%85%B7">問卷工具</a>
<ul>
<li><a href="essay/questionnaire-principal.html#microsoft-form">Microsoft Form</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E7%BC%BA%E9%BB%9E-1">缺點</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#google-form">Google Form</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E7%BC%BA%E9%BB%9E-2">缺點</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#survey-cake">Survey Cake</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E4%BD%BF%E7%94%A8%E5%A0%B4%E6%99%AF">使用場景</a></li>
<li><a href="essay/questionnaire-principal.html#%E7%BC%BA%E9%BB%9E-3">缺點</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#hotjar">Hotjar</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E4%BD%BF%E7%94%A8%E5%A0%B4%E6%99%AF-1">使用場景</a></li>
<li><a href="essay/questionnaire-principal.html#%E7%BC%BA%E9%BB%9E-4">缺點</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E5%9C%A8%E5%8F%B0%E7%81%A3%E9%9D%9E%E4%B8%BB%E6%B5%81">在台灣非主流</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E8%A3%BD%E4%BD%9C%E6%B5%81%E7%A8%8B">製作流程</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E8%8D%89%E7%A8%BF%E5%B7%A5%E5%85%B7">草稿工具</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%A8%98%E9%8C%84%E4%BF%9D%E5%AD%98">記錄保存</a></li>
<li><a href="essay/questionnaire-principal.html#%E6%96%87%E6%A1%88">文案</a></li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E5%95%8F%E5%8D%B7%E5%88%86%E6%9E%90">問卷分析</a>
<ul>
<li><a href="essay/questionnaire-principal.html#%E4%BA%A4%E5%8F%89%E5%88%86%E6%9E%90">交叉分析</a></li>
<li><a href="essay/questionnaire-principal.html#%E5%A0%B1%E5%91%8A%E6%96%B9%E5%BC%8F">報告方式</a></li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/zddKSEh.png" alt="" /></p>
<hr />
<h2 id="題項設計的原則"><a class="header" href="#題項設計的原則">題項設計的原則</a></h2>
<ul>
<li>問過去經驗與事實，避免假設性問題
<ol>
<li>預設條件寫清楚</li>
</ol>
<ul>
<li>如果未來邀請您使用，您會使用哪些功能。A. 職缺排序</li>
<li>假設未來正要開始找工作，您會想使用哪些功能。A. 職缺排序：可以將您感興趣的職缺置頂</li>
</ul>
</li>
<li>問行為，避免問思考
<ol>
<li>選擇題</li>
<li>圖案</li>
<li>讓其可以「馬上想出來」</li>
</ol>
</li>
<li>問題要足夠明確，盡可能降低模糊空間
<ul>
<li>請問您多常使用我們的服務？</li>
<li>請問您有多常使用 104 人力銀行？</li>
<li>請問您最近一個月內，多常使用 104 工作快找 APP 來應徵工作</li>
</ul>
</li>
<li>閃避不良問題
<ol>
<li>引導式問題：替填答者預設（暗示）立場</li>
<li>誘導是問題：操控、限制回答費為</li>
<li>不明確問題：如上述第三項</li>
<li>行話問題：問句中包含行話、專業術語</li>
<li>複合問題</li>
<li>多重邏輯問題</li>
</ol>
</li>
</ul>
<h3 id="封閉型選項設計原則"><a class="header" href="#封閉型選項設計原則">封閉型選項設計原則</a></h3>
<ul>
<li>ME: 彼此之間 <strong>完全獨立</strong>、<strong>毫無重疊</strong>，單選</li>
<li>CE: 整體而言 <strong>完全窮盡可能</strong>、<strong>毫無遺漏</strong>，多選</li>
</ul>
<h3 id="合理的選項數量"><a class="header" href="#合理的選項數量">合理的選項數量</a></h3>
<ul>
<li>視工具而定
<ul>
<li><em>SurveyCake</em> 可以雙欄</li>
<li><em>Hotjar</em> 單欄</li>
</ul>
</li>
<li>20 個以內</li>
<li>縮減選項
<ul>
<li>其他</li>
</ul>
</li>
</ul>
<h3 id="矩陣題"><a class="header" href="#矩陣題">矩陣題</a></h3>
<p>一題多問</p>
<h3 id="李特克量尺"><a class="header" href="#李特克量尺">李特克量尺</a></h3>
<ul>
<li>1 分、2 分、3 分、4 分、5 分</li>
<li>5 分、7 分、11 分（NPS）</li>
<li>奇數點：有中間選項</li>
<li>為數字加上文字標籤</li>
</ul>
<h3 id="既有的問卷題型可以加速製作"><a class="header" href="#既有的問卷題型可以加速製作">既有的問卷題型可以加速製作</a></h3>
<p>問卷資料庫</p>
<h3 id="問題的類型"><a class="header" href="#問題的類型">問題的類型</a></h3>
<ul>
<li><a href="essay/questionnaire-principal.html#%E6%8F%8F%E7%B9%AA%E5%87%BA%E7%9B%AE%E6%A8%99%E6%97%8F%E7%BE%A4%E9%95%B7%E7%9B%B8">描繪出目標族群長相</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%A1%8C%E7%82%BA%E3%80%81%E6%85%8B%E5%BA%A6%E3%80%81%E8%AA%8D%E7%9F%A5">行為、態度、認知</a></li>
<li><a href="essay/questionnaire-principal.html#Net-Promoter-Score-NPS">Net-Promoter-Score-NPS</a>
<ul>
<li>缺點</li>
<li>注意</li>
</ul>
</li>
<li><a href="essay/questionnaire-principal.html#%E6%9C%8D%E5%8B%99%E6%BB%BF%E6%84%8F%E5%BA%A6">服務滿意度</a></li>
<li><a href="essay/questionnaire-principal.html#%E8%B3%87%E5%AE%89">資安</a></li>
</ul>
<h4 id="描繪出目標族群長相"><a class="header" href="#描繪出目標族群長相">描繪出目標族群長相</a></h4>
<ul>
<li>性別</li>
<li>年齡</li>
<li>教育程度</li>
<li>居住地</li>
</ul>
<h4 id="行為態度認知"><a class="header" href="#行為態度認知">行為、態度、認知</a></h4>
<ul>
<li>最近一個月做了哪些服務：是否受過去經驗影響</li>
<li>滿意度、積極度：是否有特定動機</li>
<li>（不）使用原因</li>
</ul>
<h4 id="net-promoter-score-nps"><a class="header" href="#net-promoter-score-nps">Net Promoter Score (NPS)</a></h4>
<p>你有多大的意願將產品推薦給親朋好友？</p>
<p>0~10 分：</p>
<ul>
<li>0~6 批評者</li>
<li>7~8 被動者</li>
<li>9~10 推廣者</li>
<li>NPS = 推廣者比例 - 批評者比例</li>
</ul>
<h5 id="缺點"><a class="header" href="#缺點">缺點</a></h5>
<ul>
<li>什麼樣的分數是好的？</li>
<li>波動大：受行銷等影響</li>
<li>網路上的標準無法盡信</li>
</ul>
<p>跟自己賽跑</p>
<h5 id="注意"><a class="header" href="#注意">注意</a></h5>
<ul>
<li>問的是還沒發生的事情
<ul>
<li>補問：是否使用過產品</li>
</ul>
</li>
<li>切分方式太武斷
<ul>
<li>追問評分原因</li>
</ul>
</li>
</ul>
<h4 id="服務滿意度"><a class="header" href="#服務滿意度">服務滿意度</a></h4>
<ul>
<li>5 分、7 分、11 分</li>
<li>要有中間選項，避免選邊站</li>
<li>比較：比以前好就是好</li>
</ul>
<h4 id="資安"><a class="header" href="#資安">資安</a></h4>
<ul>
<li>用不到就別搜集</li>
<li>妥善保存</li>
</ul>
<hr />
<h2 id="問卷佈局"><a class="header" href="#問卷佈局">問卷佈局</a></h2>
<pre><code class="language-mermaid">graph LR
  subgraph one [起]
  標題 --&gt; 簡單問題
  end

  簡單問題 -- 承 --&gt; 真正關心的問題

  真正關心的問題 -- 轉 --&gt; 行動召喚

  行動召喚 -- 合 --&gt; 感謝語
</code></pre>
<h3 id="起"><a class="header" href="#起">起</a></h3>
<ul>
<li>基本資料</li>
<li>過去經驗</li>
</ul>
<h3 id="承"><a class="header" href="#承">承</a></h3>
<p>最關心的議題，可能需要費力思考</p>
<ul>
<li>覺得好用的功能</li>
<li>期待的功能</li>
</ul>
<h3 id="轉"><a class="header" href="#轉">轉</a></h3>
<p>希望填答者進一步採取的行動</p>
<ul>
<li>願意購買金額、願意推薦對象</li>
<li>視需求而定，不一定需要有</li>
</ul>
<h3 id="合"><a class="header" href="#合">合</a></h3>
<ul>
<li>感謝語</li>
<li>通常敏感個資會在這段（因為使用者已經填完很多問題，會想完成這個問卷）</li>
</ul>
<h3 id="需要放多少題目"><a class="header" href="#需要放多少題目">需要放多少題目</a></h3>
<p>視目的而定，抽獎、禮品可有效提升填答者意願。</p>
<ul>
<li>Hotjar 建議極短問卷
<ul>
<li>用於滿意度</li>
<li>4 題內</li>
<li>1 分鐘</li>
</ul>
</li>
<li>短問卷
<ul>
<li>基本調查</li>
<li>10 題內</li>
<li>3 分鐘</li>
</ul>
</li>
<li>中問卷
<ul>
<li>驗證假說</li>
<li>10~25</li>
<li>10 分鐘</li>
</ul>
</li>
<li>長問卷
<ul>
<li>多種交叉分析</li>
</ul>
</li>
</ul>
<hr />
<h2 id="問卷工具"><a class="header" href="#問卷工具">問卷工具</a></h2>
<h3 id="microsoft-form"><a class="header" href="#microsoft-form">Microsoft Form</a></h3>
<ul>
<li>O365 附送</li>
<li>有 NPS 預設問題</li>
<li>堪用</li>
<li>和 O365 整合</li>
</ul>
<h4 id="缺點-1"><a class="header" href="#缺點-1">缺點</a></h4>
<ul>
<li>無法使用圖片作為選項</li>
<li>不容易邏輯跳轉</li>
</ul>
<h3 id="google-form"><a class="header" href="#google-form">Google Form</a></h3>
<ul>
<li>免費</li>
<li>最廣泛</li>
<li>堪用</li>
<li>和 Google Doc 整合</li>
</ul>
<h4 id="缺點-2"><a class="header" href="#缺點-2">缺點</a></h4>
<ul>
<li>複選題原始資料不好分析</li>
</ul>
<h3 id="survey-cake"><a class="header" href="#survey-cake">Survey Cake</a></h3>
<ul>
<li>有免費版</li>
<li>台灣公司</li>
<li>功能完整、教學文件豐富</li>
<li>可在後台完成部分分析</li>
</ul>
<h4 id="使用場景"><a class="header" href="#使用場景">使用場景</a></h4>
<ul>
<li>追求良好體驗</li>
<li>最高度的客制體驗</li>
<li>問卷結果進行抽獎</li>
</ul>
<h4 id="缺點-3"><a class="header" href="#缺點-3">缺點</a></h4>
<ul>
<li>運行速度慢</li>
</ul>
<h3 id="hotjar"><a class="header" href="#hotjar">Hotjar</a></h3>
<ul>
<li>有免費版</li>
<li>插入網頁</li>
<li>形式導致題數有嚴格限制</li>
</ul>
<h4 id="使用場景-1"><a class="header" href="#使用場景-1">使用場景</a></h4>
<ul>
<li>第一印象、到站原因</li>
<li>避免評估功能題</li>
</ul>
<h4 id="缺點-4"><a class="header" href="#缺點-4">缺點</a></h4>
<ul>
<li>對用戶干擾率高</li>
<li>只能極短問卷</li>
<li>只能鑲嵌在網頁而非 APP</li>
</ul>
<h3 id="在台灣非主流"><a class="header" href="#在台灣非主流">在台灣非主流</a></h3>
<ul>
<li>Typeform
<ul>
<li>良好使用者體驗</li>
<li>有過個資外洩的經驗</li>
</ul>
</li>
<li>SurveyMonkey
<ul>
<li>僅次於 Google 的大型問卷服務</li>
<li>計算機</li>
</ul>
</li>
<li>Qualtrics
<ul>
<li>填答體驗佳</li>
<li>後台僅有英文</li>
</ul>
</li>
</ul>
<hr />
<h2 id="製作流程"><a class="header" href="#製作流程">製作流程</a></h2>
<pre><code class="language-mermaid">graph LR
  subgraph one[初步階段]
  討論 --&gt; 草稿
  草稿 --&gt; 討論
  end
  討論 --&gt; 線上版本
  線上版本 --&gt; 發送
</code></pre>
<h3 id="草稿工具"><a class="header" href="#草稿工具">草稿工具</a></h3>
<p>利用 <code>spreadsheet</code>、<code>excel</code> 等工具做草稿，方便記錄修改過程和做留言。</p>
<h3 id="記錄保存"><a class="header" href="#記錄保存">記錄保存</a></h3>
<p>把歷來的題目、選項各一頁，方便設計新的問卷</p>
<h3 id="文案"><a class="header" href="#文案">文案</a></h3>
<p>文案寫作，按照族群性質調整。</p>
<hr />
<h2 id="問卷分析"><a class="header" href="#問卷分析">問卷分析</a></h2>
<ul>
<li>不僅要追蹤問卷發送數量，也要看轉換率</li>
<li>避免可以透過資料交叉比對出一個人，保護填答者的隱私</li>
<li>若填答者不希望留下個資，要可以刪除該紀錄</li>
</ul>
<h3 id="交叉分析"><a class="header" href="#交叉分析">交叉分析</a></h3>
<ul>
<li>兩個變項彼此交叉，觀察趨勢和差異</li>
<li>Excel 的 <strong>樞紐分析</strong></li>
</ul>
<h3 id="報告方式"><a class="header" href="#報告方式">報告方式</a></h3>
<ul>
<li>用戶樣貌 Profile
<ul>
<li>圓餅圖</li>
<li>長條圖</li>
</ul>
</li>
<li>要注意抽樣誤差
<ul>
<li>Margin of Error https://cyber-edge.com/determining-minimum-survey-sample-sizes-based-on-survey-margin-of-error/</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="retry-in-http-method"><a class="header" href="#retry-in-http-method">Retry in HTTP method</a></h2>
<table><thead><tr><th>Method</th><th>Idempotent</th><th>Destructive</th><th>Safe</th><th>4XX</th><th>5XX</th><th>Ambiguous</th><th>Purpose</th></tr></thead><tbody>
<tr><td>GET</td><td>O</td><td>X</td><td>O</td><td>No Retry</td><td>Retry</td><td>Retry</td><td>取得資料</td></tr>
<tr><td>POST</td><td>X</td><td>X</td><td>X</td><td>No Retry</td><td>No Retry</td><td>No Retry</td><td>建立資料</td></tr>
<tr><td>PUT</td><td>O</td><td>O</td><td>X</td><td>No Retry</td><td>Retry</td><td>Retry</td><td>建立或編輯資料</td></tr>
<tr><td>PATCH</td><td>X</td><td>O</td><td>X</td><td>No Retry</td><td>Retry</td><td>Retry</td><td>編輯資料</td></tr>
<tr><td>DELETE</td><td>O</td><td>O</td><td>X</td><td>No Retry</td><td>Retry</td><td>Retry</td><td>刪除資料</td></tr>
</tbody></table>
<blockquote>
<p>Idempotent： 冪等的，重複執行後結果仍相同
Destructive： 破壞性的，執行後會可能會造成資料的無法復原</p>
</blockquote>
<p>PUT 可能為 <code>user.name = 'Evan'</code>，PATH 可能為 <code>user.access_count += 1</code>，故冪等是不同的。</p>
<p>若為 Destructive，可使用 <code>ETAG</code> 和 <code>If-Match</code> 的 HTTP 表頭來確認是否重複修改，或在更改過程中，從他處已經被修改。</p>
<blockquote>
<p>就如同 Memcached 的 <code>CAS</code> 值</p>
</blockquote>
<blockquote>
<p>每次 Request 中增加 idempotency key 可以用作 cache key</p>
</blockquote>
<h2 id="circuit-breaker-pattern"><a class="header" href="#circuit-breaker-pattern">Circuit Breaker Pattern</a></h2>
<p>多久 Retry 一次？</p>
<ul>
<li>網路斷線，可能僅造成數毫秒的 rejection</li>
<li>DB connection，可能造成數秒的 rejection</li>
<li>reboot 可能造成數分鐘的 rejection</li>
<li>rolling back 可能造成小時的 rejection</li>
</ul>
<p>在上述的情況下，exponential backoff 就是業界的 retry 標準，例如：</p>
<ul>
<li>100ms</li>
<li>250ms</li>
<li>500ms</li>
<li>1s</li>
<li>2.5s</li>
<li>5s</li>
<li>5s</li>
<li>...</li>
<li>quit</li>
</ul>
<h3 id="jitter"><a class="header" href="#jitter">Jitter</a></h3>
<p>若同時有許多 instance 要 retry connection，可能會導致同時間過多的 request 進入 server 中。</p>
<p><img src="https://i.imgur.com/kBdS63z.png" alt="" /></p>
<p>如上圖所示，這狀況就叫 <code>thundering herd</code>。</p>
<p>這時在各個 instance 中增加 ±10% 內的亂數會平均分散這些請求。這種做法就叫做 <code>jitter</code></p>
<pre><code class="language-javascript=">let time = SCHEDULE[times] || DEFAULT;
return Math.random() * (time * 0.2) + time * 0.9;
</code></pre>
<p>或是增加 offset：</p>
<pre><code class="language-javascript=">const PERIOD = 60_000;
const OFFSET = Math.random() * PERIOD;
setTimeout(() =&gt; {
  setInterval(() =&gt; retry(), PERIOD);
}, OFFSET);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>URL: <code>scheme://host:port/path</code></p>
<h2 id="scheme"><a class="header" href="#scheme">Scheme</a></h2>
<p><code>http</code>, <code>https</code></p>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p><code>subdomain.domain.tld</code></p>
<h3 id="top-layer-domain-tld"><a class="header" href="#top-layer-domain-tld">Top layer Domain (TLD)</a></h3>
<ul>
<li><code>com</code></li>
<li><code>com.tw</code></li>
<li><code>io</code></li>
<li><code>github.io</code></li>
</ul>
<h2 id="port"><a class="header" href="#port">Port</a></h2>
<ul>
<li><code>http</code> default <code>80</code></li>
<li><code>https</code> default <code>443</code></li>
</ul>
<h2 id="path"><a class="header" href="#path">Path</a></h2>
<p><code>/path?query_key=query_value#fragment</code></p>
<h2 id="diagram"><a class="header" href="#diagram">Diagram</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant scheme
    participant subdomain
    participant domain
    participant tld
    participant port
    domain-&gt;&gt;tld: site
    subdomain-&gt;&gt;tld: host
    scheme-&gt;&gt;port: origin
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<ul>
<li><code>https://example.com:443</code> is same origin to <code>https://example.com</code></li>
<li><code>http://eample.com:443</code> is different origin to <code>http://example.com</code> (why? <code>http</code> default <code>port</code> is 80)</li>
<li><code>http://api.example.com</code> is same site of <code>http://auth.example.com</code></li>
</ul>
<h2 id="extension"><a class="header" href="#extension">Extension</a></h2>
<ul>
<li><code>schemeful-same-site</code> consider scheme on <code>site</code></li>
<li>HTTP header <code>Sec-Fetch-Site</code>([time=April, 2020]) can know where request came from
<ul>
<li><code>same-site</code></li>
<li><code>same-origin</code></li>
<li><code>cross-site</code></li>
<li><code>none</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>介紹一些 <a href="https://www.vaultproject.io">Vault</a> 的東西</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://i.imgur.com/ghaX92s.png" alt="Vault Structure" /></p>
<hr />
<h1 id="sealunseal"><a class="header" href="#sealunseal">Seal/Unseal</a></h1>
<p>封印/解封</p>
<pre><code class="language-mermaid">graph LR
    subgraph g1 [解封]
    sf[加解密金鑰]
    end
    subgraph 初始化
    s1[(產生 加解密金鑰)] --&gt; sf
    s2[輸出 解封金鑰]
    end
    subgraph 建立和資料庫的連線&lt;br&gt;封印
    s0[沒有金鑰] --&gt; s1
    s0 -- 透過 解封金鑰 獲得 --&gt; sf
    end
</code></pre>
<hr />
<h2 id="解封金鑰換得加解密金鑰"><a class="header" href="#解封金鑰換得加解密金鑰">解封金鑰換得加解密金鑰</a></h2>
<pre><code class="language-mermaid">graph LR
    k1[解封金鑰] -- 解密&lt;br&gt;丟棄 --&gt; k2[(加密後的主鑰匙)]
    subgraph 資料庫
    k2 -- 解密&lt;br&gt;記憶 --&gt; 3[(加密後的鑰匙圈)]
    end
</code></pre>
<hr />
<h2 id="解封金鑰"><a class="header" href="#解封金鑰">解封金鑰</a></h2>
<h3 id="shamir-unseal-keys"><a class="header" href="#shamir-unseal-keys">Shamir Unseal Keys</a></h3>
<ul>
<li>需要多把鑰匙去組合出一把真正的解封金鑰</li>
<li>可設定所需金鑰的閥值</li>
<li>手動輸入</li>
</ul>
<hr />
<h3 id="auto-seal"><a class="header" href="#auto-seal">Auto Seal</a></h3>
<ul>
<li>AWSKMS, GCP Cloud KMS, OCI KMS ...</li>
<li>會產生 <code>recovery key</code></li>
<li>透過 <code>recovery key</code> <strong>授權</strong> KMS 去解封 Vault</li>
<li>透過 <code>recovery key</code> 去重新設定解封參數</li>
</ul>
<hr />
<h1 id="lease-renew-revoke"><a class="header" href="#lease-renew-revoke">Lease, Renew, Revoke</a></h1>
<p>使用特定方式驗證或服務時時會給予<code>租賃</code>，需要使用者定期<code>刷新</code>，以避免過期。</p>
<p>管理方也可<code>撤銷</code>指定的<code>租賃</code>。</p>
<hr />
<p>例如：動態獲得 <code>AWS</code> 的存取權杖</p>
<pre><code class="language-bash">$ vault read aws/creds/my-role
Key             Value
---             -----
lease_id        aws/creds/my-role/f3e92392-7d9c-09c8-c921-575d62fe80d8
lease_duration  768h
lease_renewable true
access_key      AKIAIOWQXTLW36DV7IEA
secret_key      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
security_token  &lt;nil&gt;

</code></pre>
<hr />
<h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>驗證過後才能執行所有需要執行的動作，除了最一開始的 <code>init</code> 和 <code>unseal</code>。</p>
<h2 id="驗證方法"><a class="header" href="#驗證方法">驗證方法</a></h2>
<p>GitHub, LDAP, AppRole ...</p>
<h2 id="tokens"><a class="header" href="#tokens">Tokens</a></h2>
<p>驗證成功會給予 token</p>
<hr />
<h1 id="tokens-1"><a class="header" href="#tokens-1">Tokens</a></h1>
<p>權杖</p>
<ul>
<li>最一開始的權杖 即是在建立之初所得到的 <code>Root Token</code></li>
<li>透過設定，允許不同的<a href="essay/vault/introduction.html#%E9%A9%97%E8%AD%89%E6%96%B9%E6%B3%95">驗證方法</a>，每次登入都會給予一個權杖</li>
<li>透過<a href="essay/vault/introduction.html#Policy">政策</a>去管理</li>
<li>有時候會透過權杖去取得<code>租賃</code>。</li>
</ul>
<hr />
<h2 id="root-token"><a class="header" href="#root-token">Root Token</a></h2>
<p>根權杖</p>
<ul>
<li>應該在初始化操作（<a href="essay/vault/introduction.html#%E9%A9%97%E8%AD%89%E6%96%B9%E6%B3%95">驗證方法</a>和<a href="essay/vault/introduction.html#Policy">政策</a>）後<code>撤銷</code></li>
<li>若有需要根權杖，可透過 <code>vault operator generate-root</code> 去產生
<ul>
<li>需要解封鑰匙</li>
<li><a href="https://learn.hashicorp.com/tutorials/vault/generate-root">詳見</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="權杖的制度"><a class="header" href="#權杖的制度">權杖的制度</a></h2>
<ul>
<li>透過權杖，可以生產全新的權杖，此時該權杖稱為子權杖，若建立子權杖的權杖被撤銷，子權杖同時會被撤銷
<ul>
<li>避免過大的家族導致撤銷的困難</li>
</ul>
</li>
<li>仍能特過特殊方式建立沒有父母的權杖 <code>Orphan Token</code>，<a href="https://www.vaultproject.io/docs/concepts/tokens#token-hierarchies-and-orphan-tokens">詳見</a></li>
</ul>
<hr />
<h2 id="權杖的-accessor"><a class="header" href="#權杖的-accessor">權杖的 accessor</a></h2>
<p>用來代表該權杖的路標，可用此路標</p>
<ul>
<li>查看該權杖的資訊，除了權杖 ID 本身，<a href="https://www.vaultproject.io/docs/commands/token/lookup#examples">詳見</a></li>
<li>查看該權杖可否使用可以特定權利（僅能 API），<a href="https://www.vaultproject.io/api-docs/system/capabilities-accessor#sys-capabilities-accessor">詳見</a></li>
<li>撤銷權杖，<a href="https://www.vaultproject.io/docs/commands/token/revoke#examples">詳見</a></li>
<li>重新計算權杖的過期時間（僅限 API），<a href="https://www.vaultproject.io/api-docs/auth/token#renew-a-token-accessor">詳見</a></li>
</ul>
<hr />
<h2 id="權杖的過期"><a class="header" href="#權杖的過期">權杖的過期</a></h2>
<ul>
<li>可重新計算權杖的過期時間。並非疊加，而是重新計算</li>
<li>給予機器短時間的權杖，並要求短時間內重新計算過期時間。以確保機器存活狀態</li>
<li>給予非機器長時間（32 天）的權杖</li>
</ul>
<hr />
<h2 id="batch-tokens"><a class="header" href="#batch-tokens">Batch Tokens</a></h2>
<ul>
<li>權杖中含有足夠的資訊去做事情</li>
<li>若沒有父母，可以在不同的機器（Node）間使用</li>
</ul>
<pre><code class="language-bash=">$ vault token create -type=batch -orphan=true -policy=my-policy

Key                  Value
---                  -----
token                b.AAAAAQKn0sVCMJNVTBWHXpwjQ1HbgpyDsJ8WeKtVaZiiUCLK13uT4-pknd0lsHyiXVw7jaRy2U03o0K-TjtEU40v5f26KZXiY12vlMakT1WZuL-NdQ6pGD9fj4YGRp39qKY_jbQyrx8
token_accessor       n/a
token_duration       768h
token_renewable      false
token_policies       [&quot;default&quot; &quot;my-policy&quot;]
identity_policies    []
policies             [&quot;default&quot; &quot;my-policy&quot;]
</code></pre>
<hr />
<h1 id="response-wrapping"><a class="header" href="#response-wrapping">Response Wrapping</a></h1>
<ol>
<li>一台機器驗證通過後得到權杖，並持續更新權杖保持其可用性。
<ul>
<li>但是機器如果需要重啟？</li>
</ul>
</li>
<li>不能保證機器的合法性，但需要他獲得權杖
<ul>
<li>手機 app</li>
</ul>
</li>
</ol>
<p>把權杖包裝（Wrapping）起來給指定機器。</p>
<pre><code class="language-bash=">$ vault token create -policy=apps -wrap-ttl=120
</code></pre>
<hr />
<pre><code class="language-mermaid">graph LR
    root -- 1. 要求包裝權杖 --&gt; Vault
    root -- 2. 寄送包裝權杖 --&gt; APP
    APP -- 3. 透過包裝權杖取得權杖 --&gt; Vault
    APP -- 4. 特過權杖取得資訊 --&gt; Vault
</code></pre>
<hr />
<h2 id="關於包裝權杖"><a class="header" href="#關於包裝權杖">關於包裝權杖</a></h2>
<ul>
<li>若沒有包裝權杖仍可透過 <code>unwrap-accessor</code> 去撤銷其代表的權杖</li>
<li>包裝權杖並未做簽證（sign），因為其利用 key-value 去獲得真正的權杖，<a href="https://www.vaultproject.io/docs/concepts/response-wrapping#response-wrapping-tokens">詳見</a></li>
<li><a href="https://hackmd.io/idIbJh-aRj-yT7_1Q5AqKQ#Wrapping-Token">實作</a></li>
</ul>
<hr />
<h2 id="安全性做法"><a class="header" href="#安全性做法">安全性做法</a></h2>
<ul>
<li>建立 Audit Log Device 做紀錄。</li>
<li>每次得到包裝權杖，執行 Look-up，可以得到建造其的位置，並做驗證。</li>
</ul>
<hr />
<h1 id="policy"><a class="header" href="#policy">Policy</a></h1>
<p>政策</p>
<ul>
<li>根據驗證方式，可以設計不同單位（甚至個體）不同政策</li>
<li>通常是限制可以獲取哪些資料和對該資料的處理權限</li>
<li><code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>list</code></li>
<li><code>sudo</code>, <code>deny</code></li>
<li>可以要求指定資料必須<code>包裝</code></li>
</ul>
<hr />
<pre><code class="language-mermaid">graph LR
    root -- 建立驗證方式 --&gt; Vault
    root -- 政策 --&gt; Vault
    Vault -- 儲存 --&gt; k[(資料庫)]
</code></pre>
<pre><code class="language-mermaid">graph LR
    user -- 1. 驗證 --&gt; Vault
    Vault -- 2. 確認 --&gt; 驗證機構
    k[(資料庫)] -- 3. 政策 --&gt; Vault
    Vault -- 4.權杖 --&gt; user
</code></pre>
<hr />
<h2 id="注意事項"><a class="header" href="#注意事項">注意事項</a></h2>
<ul>
<li>寫作方式，<a href="https://www.vaultproject.io/docs/concepts/policies#policy-syntax">詳見</a></li>
<li>政策模板，讓每個人僅能讀取各自的資料，<a href="https://www.vaultproject.io/docs/concepts/policies#templated-policies">詳見</a></li>
<li>限制特定 key-value 的存取，<a href="https://www.vaultproject.io/docs/concepts/policies#parameter-constraints">詳見</a></li>
<li>列表、讀取、編輯、刪除，<a href="https://www.vaultproject.io/docs/concepts/policies#managing-policies">詳見</a></li>
</ul>
<hr />
<h1 id="high-availability"><a class="header" href="#high-availability">High Availability</a></h1>
<p><img src="https://i.imgur.com/5diYphY.png" alt="Relation between cluster and node" /></p>
<hr />
<ul>
<li>Standby-node 只會把需求<strong>重新導向</strong>至 Active-node</li>
<li>Standby-node 透過<strong>資料庫</strong>得到 Active-node 的資訊</li>
<li>一般來說，效能瓶頸是來自於資料庫的編輯和存取</li>
<li>Performance Standby-node（付費）
<ul>
<li>允許 Standby-node 讀取資料</li>
</ul>
</li>
</ul>
<hr />
<h2 id="重新導向"><a class="header" href="#重新導向">重新導向</a></h2>
<ol>
<li>Standby-node 和 Active-node 溝通（預設值）
<ul>
<li>透過<strong>資料庫</strong>的私鑰和簽章來和 Active node 做 TLS1.2 溝通</li>
<li><code>cluster_address</code></li>
</ul>
</li>
<li>Standby-node 回應 <code>307</code> 給使用者，並要求重新導向至 Active-node
<ul>
<li>若有 Load Balance 可以重新導向至此</li>
<li><code>api_address</code></li>
</ul>
</li>
</ol>
<hr />
<h1 id="integrated-storage"><a class="header" href="#integrated-storage">Integrated Storage</a></h1>
<p>如果資料庫不能連線了...？</p>
<blockquote>
<p>建立多個資料庫並整合</p>
</blockquote>
<ol>
<li><a href="http://thesecretlivesofdata.com/raft">RAFT</a> - 幫助多個資料庫的整合</li>
<li>資料庫是用 File System</li>
<li>每個 Node 都需要有一個獨立的資料庫，但是會和其他 Node 整合</li>
</ol>
<hr />
<h1 id="計數"><a class="header" href="#計數">計數</a></h1>
<ul>
<li>API，<a href="https://learn.hashicorp.com/tutorials/vault/resource-quotas">詳見</a>
<ul>
<li>可以限制其次數</li>
</ul>
</li>
<li>User，<a href="https://www.vaultproject.io/docs/concepts/client-count">詳見</a>
<ul>
<li>獨立個體（透過特定驗證方式）+ 非獨立個體的權杖</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-設定"><a class="header" href="#server-設定">Server 設定</a></h1>
<pre><code class="language-json=">{
  &quot;storage&quot;: {
    &quot;mysql&quot;: {
      &quot;address&quot;: &quot;127.0.0.1:3306&quot;,
      &quot;database&quot;: &quot;playground&quot;,
      &quot;table&quot;: &quot;vault&quot;,
      &quot;username&quot;: &quot;root&quot;,
      &quot;password&quot;: &quot;mysql-password&quot;,
      &quot;plaintext_connection_allowed&quot;: true,
      &quot;ha_enabled&quot;: true
    }
  },
  &quot;listener&quot;: {
    &quot;tcp&quot;: {
      &quot;tls_disable&quot;: true
    }
  },
  &quot;seal&quot;: {
    &quot;awskms&quot;: {
      &quot;region&quot;: &quot;ap-northeast-1&quot;,
      &quot;access_key&quot;: &quot;aws-iam-access-key&quot;,
      &quot;secret_key&quot;: &quot;aws-iam-secret-key&quot;,
      &quot;kms_key_id&quot;: &quot;aws-kms-key-id&quot;
    }
  },
  &quot;ui&quot;: true,
  &quot;disable_mlock&quot;: true,
  &quot;api_addr&quot;: &quot;http://127.0.0.1:8200&quot;,
  &quot;cluster_addr&quot;: &quot;https://127.0.0.1:8201&quot;
}
</code></pre>
<pre><code class="language-bash=">$ vault server -config=config.json
</code></pre>
<hr />
<h1 id="sealunseal-1"><a class="header" href="#sealunseal-1">Seal/Unseal</a></h1>
<p>初始化並獲得 <code>Recovery Key</code> 和 <code>Root Token</code></p>
<pre><code class="language-bash=">$ vault operator init -recovery-shares=1 -recovery-threshold=1

Recovery Key 1: fFtAyv+N/h4YdgQmLveOleONswIYmNorw6E65Jv7ciU=
Initial Root Token: s.9gFtHEu35b4FCBHbUtaLxeOw
</code></pre>
<pre><code class="language-bash=">$ vault status

Key                    Value
---                    -----
Recovery Seal Type     shamir
Initialized            true
Sealed                 false
Total Recovery Shares  1
Threshold              1
Version                1.6.1
Storage Type           mysql
Cluster Name           vault-cluster-d4a98a31
Cluster ID             06bbee1f-d643-31c1-a87b-ba43d3b1d2d3
HA Enabled             true
HA Cluster             https://127.0.0.1:8201
HA Mode                active
</code></pre>
<h2 id="mysql"><a class="header" href="#mysql">MySQL</a></h2>
<p>可以看到主鑰和加密金曜都已經建立好了</p>
<pre><code>vault_key     vault_value
---------     -----------
core/keyring  ...
core/master   ...
</code></pre>
<h2 id="login"><a class="header" href="#login">Login</a></h2>
<pre><code class="language-bash=">$ vault login s.9gFtHEu35b4FCBHbUtaLxeOw
</code></pre>
<h2 id="seal"><a class="header" href="#seal">Seal</a></h2>
<p>重新封印並再解封的話要輸入 <code>Recovery Key</code></p>
<blockquote>
<p>注意：若重新申請一個 <code>Root Token</code>，也會需要 <code>Recovery Key</code></p>
</blockquote>
<pre><code class="language-bash=">$ vault operator seal
$ vault operator unseal

Unseal Key (will be hidden):
</code></pre>
<h1 id="secrets"><a class="header" href="#secrets">Secrets</a></h1>
<p>key-value 的資料庫</p>
<pre><code class="language-bash=">$ vault secrets enable -path=secret kv
$ vault kv put secret/hello foo=world
$ vault kv list secret
$ vault kv get secret/hello
</code></pre>
<h2 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h2>
<p>可以看到資料庫依此建立了新的路徑，<code>secret/hello</code> 中的 <code>secret</code> 被加密了</p>
<pre><code>vault_key                                           vault_value
---------                                           -----------
logical/beefac89-6bc8-6bfd-1af8-c1436c19926c/hello  ...
</code></pre>
<h1 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h1>
<p>先允許 GitHub 登入</p>
<pre><code class="language-bash=">$ vault auth enable github
$ vault write auth/github/config organization=104corp
</code></pre>
<h2 id="登出"><a class="header" href="#登出">登出</a></h2>
<pre><code class="language-bash=">$ rm ~/.vault-token
</code></pre>
<h2 id="github"><a class="header" href="#github">GitHub</a></h2>
<h3 id="存取權杖"><a class="header" href="#存取權杖">存取權杖</a></h3>
<p>去 <a href="https://github.com/settings/profile">GitHub 設定頁</a> &gt; Developer settings &gt; Personal access tokens &gt; Generate new token</p>
<p>權限要有：<code>admin:org &gt; read:org</code>，讓 Vault 可以讀取你帳號的組織</p>
<h3 id="登入"><a class="header" href="#登入">登入</a></h3>
<pre><code class="language-bash=">$ vault login -method=github -token=access-token-from-github

Key                  Value
---                  ------
token                s.AtDndppL6auMYfI27zfkvgn1
token_accessor       WC8tFkMglS9S3RLtitHdAtRe
token_duration       768h
token_renewable      true
token_policies       [&quot;default&quot;]
identity_policies    []
policies             [&quot;default&quot;]
token_meta_username  evan361425
token_meta_org       104corp
</code></pre>
<h3 id="資訊"><a class="header" href="#資訊">資訊</a></h3>
<pre><code class="language-bash=">$ vault token lookup s.AtDndppL6auMYfI27zfkvgn1

Key                 Value
---                 -----
accessor            WC8tFkMglS9S3RLtitHdAtRe
creation_time       1610344081
creation_ttl        768h
display_name        github-evan361425
entity_id           7b404dd3-5b23-da3f-663c-76a66e84ebe8
expire_time         2021-02-12T13:48:01.492935+08:00
explicit_max_ttl    0s
id                  s.AtDndppL6auMYfI27zfkvgn1
issue_time          2021-01-11T13:48:01.492956+08:00
meta                map[org:104corp username:evan361425]
num_uses            0
orphan              true
path                auth/github/login
policies            [default]
renewable           true
ttl                 767h36m19s
type                service
</code></pre>
<h1 id="token"><a class="header" href="#token">Token</a></h1>
<p>先重新登入回 <code>Root Token</code></p>
<pre><code class="language-bash="># 看看現在是用什麼權杖
$ vault print token
s.AtDndppL6auMYfI27zfkvgn1
# 此權杖並非 Root Token，登出
$ rm ~/.vault-token
$ vault login s.9gFtHEu35b4FCBHbUtaLxeOw
</code></pre>
<h2 id="列出所有-token-的-accessor"><a class="header" href="#列出所有-token-的-accessor">列出所有 token 的 accessor</a></h2>
<pre><code class="language-bash=">$ vault list auth/token/accessors
</code></pre>
<h2 id="batch-token"><a class="header" href="#batch-token">Batch Token</a></h2>
<p>先建立 <a href="essay/vault/implementation.html#Policy">Policy</a></p>
<pre><code class="language-bash=">$ vault token create -type=batch -orphan=true -policy=my-policy

Key                  Value
---                  -----
token                b.AAAAAQKn0sVCMJNVTBWHXpwjQ1HbgpyDsJ8WeKtVaZiiUCLK13uT4-pknd0lsHyiXVw7jaRy2U03o0K-TjtEU40v5f26KZXiY12vlMakT1WZuL-NdQ6pGD9fj4YGRp39qKY_jbQyrx8
token_accessor       n/a
token_duration       768h
token_renewable      false
token_policies       [&quot;default&quot; &quot;my-policy&quot;]
identity_policies    []
policies             [&quot;default&quot; &quot;my-policy&quot;]
</code></pre>
<p>batch token 開頭是 <code>b</code>，反之，常見的 token 是 <code>s</code> 開頭，代表 service token</p>
<h2 id="wrapping-token"><a class="header" href="#wrapping-token">Wrapping Token</a></h2>
<pre><code class="language-bash=">$ vault token create -policy=my-policy -wrap-ttl=120

Key                              Value
---                              -----
wrapping_token:                  s.F7S12zD0PUcEL5VShhElBZIb
wrapping_accessor:               LsfBV3JiC4zwWCaFEZqNW9db
wrapping_token_ttl:              2m
wrapping_token_creation_time:    2021-01-11 16:49:11.614054 +0800 CST
wrapping_token_creation_path:    auth/token/create
wrapped_accessor:                oW7NNQUM35G7mvTQ4vieDPqi
</code></pre>
<pre><code class="language-bash=">vault unwrap s.F7S12zD0PUcEL5VShhElBZIb

Key                  Value
---                  -----
token                s.v8lwNg4uwfZzlHvDrmPdkRyF
token_accessor       oW7NNQUM35G7mvTQ4vieDPqi
token_duration       768h
token_renewable      true
token_policies       [&quot;default&quot; &quot;my-policy&quot;]
identity_policies    []
policies             [&quot;default&quot; &quot;my-policy&quot;]
</code></pre>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<pre><code class="language-bash=">$ curl \
    --header &quot;X-Vault-Token: s.9gFtHEu35b4FCBHbUtaLxeOw&quot; \
    --header &quot;X-Vault-Wrap-TTL: 60&quot; \
    --request POST \
    --data &quot;{\&quot;foo\&quot;: \&quot;bar\&quot;}&quot; \
    http://127.0.0.1:8200/v1/sys/wrapping/wrap
{
  &quot;request_id&quot;: &quot;&quot;,
  &quot;lease_id&quot;: &quot;&quot;,
  &quot;renewable&quot;: false,
  &quot;lease_duration&quot;: 0,
  &quot;data&quot;: null,
  &quot;wrap_info&quot;: {
    &quot;token&quot;: &quot;s.3MeMoyxudk19RHKzCZAa55oi&quot;,
    &quot;accessor&quot;: &quot;6rKApXj7R8iNz3gZjkIpd8Y4&quot;,
    &quot;ttl&quot;: 60,
    &quot;creation_time&quot;: &quot;2021-01-11T17:08:44.876296+08:00&quot;,
    &quot;creation_path&quot;: &quot;sys/wrapping/wrap&quot;
  },
  &quot;warnings&quot;: null,
  &quot;auth&quot;: null
}
</code></pre>
<hr />
<pre><code class="language-bash=">$ curl \
    --header &quot;X-Vault-Token: s.9gFtHEu35b4FCBHbUtaLxeOw&quot; \
    --request POST \
    --data &quot;{\&quot;token\&quot;:\&quot;s.3MeMoyxudk19RHKzCZAa55oi\&quot;}&quot; \
    http://127.0.0.1:8200/v1/sys/wrapping/lookup
{
  &quot;request_id&quot;: &quot;67be1f69-e921-0eac-a660-5aa4f2761cb1&quot;,
  &quot;lease_id&quot;: &quot;&quot;,
  &quot;renewable&quot;: false,
  &quot;lease_duration&quot;: 0,
  &quot;data&quot;: {
    &quot;creation_path&quot;: &quot;sys/wrapping/wrap&quot;,
    &quot;creation_time&quot;: &quot;2021-01-11T17:11:00.784059+08:00&quot;,
    &quot;creation_ttl&quot;: 60
  },
  &quot;wrap_info&quot;: null,
  &quot;warnings&quot;: null,
  &quot;auth&quot;: null
}
</code></pre>
<h1 id="policy-1"><a class="header" href="#policy-1">Policy</a></h1>
<h2 id="讀取現有的政策"><a class="header" href="#讀取現有的政策">讀取現有的政策</a></h2>
<pre><code class="language-bash=">$ vault read sys/policy

Key         Value
---         -----
keys        [default root]
policies    [default root]
</code></pre>
<h2 id="建立政策"><a class="header" href="#建立政策">建立政策</a></h2>
<pre><code class="language-bash=">$ vault policy write my-policy policy.hcl
</code></pre>
<p><code>policy.hcl</code> 檔：</p>
<pre><code class="language-hcl">path &quot;secret/*&quot; {
  capabilities = [&quot;create&quot;, &quot;read&quot;, &quot;update&quot;, &quot;delete&quot;, &quot;list&quot;]
}

path &quot;secret/hello&quot; {
  capabilities = [&quot;deny&quot;]
}

path &quot;secret/restricted&quot; {
  capabilities = [&quot;create&quot;]
  allowed_parameters = {
    &quot;foo&quot; = []
    &quot;bar&quot; = [&quot;zip&quot;, &quot;zap&quot;]
  }
}
</code></pre>
<h1 id="high-availability-1"><a class="header" href="#high-availability-1">High Availability</a></h1>
<p>Different from <a href="essay/vault/implementation.html#Server-%E8%A8%AD%E5%AE%9A">config</a></p>
<pre><code class="language-json=">{
  &quot;listener&quot;: {
    &quot;tcp&quot;: {
      &quot;address&quot;: &quot;127.0.0.1:8100&quot;,
      &quot;cluster_address&quot;: &quot;127.0.0.1:8101&quot;
    }
  }
}
</code></pre>
<pre><code class="language-bash=">$ export VAULT_ADDR=&quot;http://127.0.0.1:8100&quot;
$ vault status

Key                      Value
---                      -----
Recovery Seal Type       shamir
Initialized              true
Sealed                   false
Total Recovery Shares    1
Threshold                1
Version                  1.6.1
Storage Type             mysql
Cluster Name             vault-cluster-d4a98a31
Cluster ID               06bbee1f-d643-31c1-a87b-ba43d3b1d2d3
HA Enabled               true
HA Cluster               https://127.0.0.1:8201
HA Mode                  standby
Active Node Address      http://127.0.0.1:8200
</code></pre>
<h1 id="rate-limit"><a class="header" href="#rate-limit">Rate Limit</a></h1>
<pre><code class="language-bash=">$ vault read sys/quotas/config

Key                                   Value
---                                   -----
enable_rate_limit_audit_logging       false
enable_rate_limit_response_headers    false
rate_limit_exempt_paths               [
                                        /v1/sys/generate-recovery-token/attempt
                                        /v1/sys/generate-recovery-token/update
                                        /v1/sys/generate-root/attempt
                                        /v1/sys/generate-root/update
                                        /v1/sys/health
                                        /v1/sys/seal-status
                                        /v1/sys/unseal
                                      ]
</code></pre>
<h2 id="存取編輯"><a class="header" href="#存取編輯">存取、編輯</a></h2>
<pre><code class="language-bash=">$ vault write sys/quotas/rate-limit/global-rate rate=500
$ vault read sys/quotas/rate-limit/global-rate

Key               Value
---               -----
block_interval    0
interval          1
name              global-rate
path              n/a
rate              500
type              rate-limit
</code></pre>
<pre><code class="language-bash=">$ vault write sys/quotas/rate-limit/global-rate rate=501
$ vault delete sys/quotas/rate-limit/global-rate
</code></pre>
<h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<pre><code class="language-bash=">$ vault debug
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>公開金鑰基礎建設 Public Key Infrastructure</p>
<h1 id="傳統流程"><a class="header" href="#傳統流程">傳統流程</a></h1>
<ol>
<li>建立 Certificate Signing Request (CSR)
<ul>
<li>自己產生公私鑰</li>
<li>用私鑰簽署 CSR</li>
</ul>
</li>
<li>寄發 CSR 給 Certificate Authority (CA)</li>
<li>CA 簽署該 CSR
<ul>
<li>回傳的東西就是你的 Certificate</li>
</ul>
</li>
<li>若撤銷 CSR 則可能
<ul>
<li>更新 CA 本地端的 Certificate Revocation List (CRL)</li>
<li>或線上的 Online Certificate Status Protocal (OCSP)</li>
</ul>
</li>
</ol>
<hr />
<h1 id="有-vault-的流程"><a class="header" href="#有-vault-的流程">有 Vault 的流程</a></h1>
<hr />
<h2 id="若-root-ca-放在-vault-外面"><a class="header" href="#若-root-ca-放在-vault-外面">若 root CA 放在 Vault 外面</a></h2>
<ol>
<li>建立 root CA 在 Vault 外面</li>
<li>建立 intermediate CA 在 Vault 裡面</li>
<li>建立 intermediate CA 的 CSR</li>
<li>拿出 CSR 並給 root CA 簽署後放進 Vault 裡面</li>
</ol>
<hr />
<h2 id="若-root-ca-在-vault-裡面"><a class="header" href="#若-root-ca-在-vault-裡面">若 root CA 在 Vault 裡面</a></h2>
<p>順著上述流程打 API 就好
Vault 會幫我們做好各種溝通</p>
<hr />
<h1 id="撤銷"><a class="header" href="#撤銷">撤銷</a></h1>
<ul>
<li>短期的 TTL 可以省掉撤銷的機制，並且縮短 CRL 的長度</li>
<li>不建議利用 command 撤銷，多利用短期的 TTL 和自動化去達到安全性</li>
</ul>
<h1 id="demo"><a class="header" href="#demo">Demo</a></h1>
<h2 id="環境"><a class="header" href="#環境">環境</a></h2>
<pre><code class="language-bash=">$ vault secrets enable -path=root-pki pki
</code></pre>
<h2 id="建立-root-ca"><a class="header" href="#建立-root-ca">建立 root CA</a></h2>
<pre><code class="language-bash=">$ vault write root-pki/root/generate/internal \
  common_name=&quot;My Root CA&quot; \
  ttl=24h

# issuing certificate, CRL distribution points, and OCSP server endpoints
$ vault write root-pki/config/urls \
  issuing_certificates=&quot;$VAULT_ADDR/v1/root-pki/ca&quot; \
  crl_distribution_points=&quot;$VAULT_ADDR/v1/root-pki/crl&quot;

# See configuration
$ curl -s &quot;$VAULT_ADDR/v1/root-pki/ca/pem&quot; | openssl x509 -text
</code></pre>
<blockquote>
<p><code>/ca/pem</code> 無法透過 CLI 獲得，且不需驗證即可得到該值。
<a href="https://www.vaultproject.io/api-docs/secret/pki#read-ca-certificate">相關說明</a></p>
</blockquote>
<pre><code>-----BEGIN CERTIFICATE-----
MIIDITCCAgmgAwIBAgIUB+EbBBHSHVRn+onGcck9Fq8MI0EwDQYJKoZIhvcNAQEL
BQAwGDEWMBQGA1UEAxMNVmF1bHQgUm9vdCBDQTAeFw0yMTA3MjYwODQ4NDNaFw0y
MTA3MjYwOTQ5MTJaMBgxFjAUBgNVBAMTDVZhdWx0IFJvb3QgQ0EwggEiMA0GCSqG
SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtIl1caDwF/H4TiB7PwGRvc3FrSZfp0A5A
jPOGkcP8x0aNDz+RV+WVya2ANNXou4rIICWJDhkfUTNXkDXVCOcxeCl6x211EP69
6BkyGvbf7bIhMVcMmrzNqoHWSBFdPT0/rztdlUTgmW0ukYEdfSghrsGsaaAbxyyE
aze+5dESuFQv+RXWp34kX81UJt+Z3e39DrjBWPDCoJUM6g6IijRgy0vVdV05GHmS
SKGPqf03/2Iw9xmDEui4iomclqwvmG07UivEdD1pb4nZJBmCLnWXTe/5a9+1QdQf
7xEFAMpXOqHG9EQJWzG3rjNb5MhR+VXytNDq6nteEbaaiQwB6KhXAgMBAAGjYzBh
MA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTCy+Pz
4mqP6gnIkXkeq88JW4ExFDAfBgNVHSMEGDAWgBTCy+Pz4mqP6gnIkXkeq88JW4Ex
FDANBgkqhkiG9w0BAQsFAAOCAQEADdzNcD085699P/cB24JKFk49zidHe33NwEI0
7Y9tPaAChPc6ZDOUX1wguy2QL8NpZNKbxAU73HXFKHK1UOGgJQxzOUKdGLRAKc5z
E7pUF1lAyG2caJ4XtuECXKcFI/m2oaI5v+Mj8eeEv0PqV5aOmKqBsJfDtepZRYdj
0wzV8gyag2Y9rLMeveUmWF73y2l6g7KspSF0YXqzjZTJQj5oQcAmvdxSmKB8UBYD
1Rpa5Wdoq/XMwFPxL3b3qFuK+seGZzwvY9WGey5kAZQBZkkkWw519ZFGdiU1/Xjm
L4zS/WOwyBRamvriYB2fG09Vtr+i+tGsghgzEm1smu0uSSPNhA==
-----END CERTIFICATE-----%
</code></pre>
<h2 id="建立-intermediate-ca"><a class="header" href="#建立-intermediate-ca">建立 intermediate CA</a></h2>
<pre><code class="language-bash=">$ vault secrets enable -path=int-pki pki
$ vault write -field=csr \
  int-pki/intermediate/generate/internal \
  common_name=&quot;My Intermediate CA&quot; \
  ttl=12h &gt; cert/intermediate.csr

# Get signed CSR from root
$ vault write -field=certificate \
  root-pki/root/sign-intermediate \
  csr=@cert/intermediate.csr \
  format=pem_bundle \
  ttl=12h &gt; cert/intermediate.crt

# Root CA sign intermediate
$ vault write int-pki/intermediate/set-signed \
  certificate=@cert/intermediate.crt

# Urls
$ vault write int-pki/config/urls \
  issuing_certificates=&quot;$VAULT_ADDR/v1/int-pki/ca&quot; \
  crl_distribution_points=&quot;$VAULT_ADDR/v1/int-pki/crl&quot;

# Set role
$ vault write int-pki/roles/example-dot-com \
  allowed_domains=example.com \
  allow_subdomains=true \
  allow_glob_domains=true \
  generate_lease=true \
  max_ttl=1m \
  ttl=1m
</code></pre>
<blockquote>
<p>上述建立的 public url 可透過 <code>curl $VAULT_ADDR/vi/int-pki/ca/pem</code>，以 PEM 格式取得。</p>
</blockquote>
<p>取得的 CA，可以看到有效期限是 12 小時：</p>
<pre><code>Common Name: My Intermediate CA
Issuing Certificate: My Root CA
Serial Number: 2EEF1ACC06016AE04CE00FE575D7426CEE982582
Signature: sha256WithRSAEncryption
Valid From: 07:16:44 21 Jul 2021
Valid To: 19:17:14 21 Jul 2021
Key Usage: Certificate Sign, CRL Sign
Basic Constraints: CA:TRUE
Subject Key Identifier: 46:C4:1E:F3:5B:EE:3D:64:88:37:CF:67:A8:E5:11:82:B5:CE:F0:18
Authority Key Identifier: keyid:71:37:14:BE:9B:66:E7:93:3E:4A:45:F1:B3:78:6E:37:30:38:CC:4D
Authority Info Access: CA Issuers - URI:http://localhost:8200/v1/root-pki/ca
</code></pre>
<p>取得的 CRL，待會 revoke certificate 之後可以看其變化：</p>
<pre><code>Version: 2
IssuerDN: CN=My Intermediate CA
This update: Wed Jul 21 07:17:31 UTC 2021
Next update: Sat Jul 24 07:17:31 UTC 2021
Signature Algorithm: SHA256WITHRSA
Signature: 282359565d73c1ab950771e685ec352827967bd0
           a969e57cbacad44d2c435d4478de6f6139ef8594
           59fd862df7f61894f79cd1e775104ef45da7a95f
           7749ee639fda5a0e12a7a7b211d875aaf1c6a876
           7e5089492d38bd0098c4adc3d57d51fa7f5a90e6
           4ae2fd715376b65cd58a004002002b8d91a0251d
           1f01d0bdcead7784d5b55a7ce010a1830452bbd1
           2b37f62e3d85bc62c8f05111c8cbbfdc554f27ff
           588cc2efa77cd462d02a0026dc19fc5fd64b3021
           cf6bf17279e9b1ab1f13a03e3737dbe60601828f
           1e3cc669b508837b602abb9dcb221ae05047a7d4
           22859538c78eb44887cef9cdd62adf45abc8f278
           dad4dada9835ef6eccbe3a7ccd1a915b
Extensions: critical(false) 2.5.29.35 value = Sequence Tagged [0] IMPLICIT DER Octet String[20]
</code></pre>
<h2 id="建立-token"><a class="header" href="#建立-token">建立 Token</a></h2>
<h3 id="policy-2"><a class="header" href="#policy-2">Policy</a></h3>
<p>policy.hcl</p>
<pre><code class="language-hcl="># Intermediate CA issue you!
path &quot;int-pki/issue/example-dot-com&quot; {
  &quot;capabilities&quot; = [&quot;create&quot;, &quot;update&quot;]
}

# Root CA verify cert!
path &quot;root-pki/cert/ca&quot; {
  &quot;capabilities&quot; = [&quot;read&quot;]
}

# Token
path &quot;auth/token/renew&quot; {
  &quot;capabilities&quot; = [&quot;update&quot;]
}
path &quot;auth/token/renew-self&quot; {
  &quot;capabilities&quot; = [&quot;update&quot;]
}
</code></pre>
<h3 id="設定-policy-和建立-token"><a class="header" href="#設定-policy-和建立-token">設定 policy 和建立 token</a></h3>
<pre><code class="language-bash="># Policy
$ vault policy write intermediate-pki policy.hcl
# Token
$ vault token create \
  -field=token \
  -policy=intermediate-pki \
  -ttl=1h &gt; pki.token
</code></pre>
<h2 id="利用-consul-template-去自動要-certificate"><a class="header" href="#利用-consul-template-去自動要-certificate">利用 consul-template 去自動要 certificate</a></h2>
<h3 id="template"><a class="header" href="#template">Template</a></h3>
<p>certificate.tpl</p>
<pre><code class="language-tpl=">{{- with secret &quot;int-pki/issue/example-dot-com&quot; &quot;common_name=blah.example.com&quot; -}}
{{ .Data.certificate }}{{ end }}
</code></pre>
<p>key.tpl</p>
<pre><code class="language-tpl=">{{- with secret &quot;int-pki/issue/example-dot-com&quot; &quot;common_name=blah.example.com&quot; -}}
{{ .Data.private_key }}{{ end }}
</code></pre>
<h3 id="consul-template-的參數"><a class="header" href="#consul-template-的參數">consul-template 的參數</a></h3>
<p>config.hcl</p>
<pre><code class="language-hcl=">vault {
  address = &quot;http://127.0.0.1:8200&quot;
  vault_agent_token_file = &quot;pki.token&quot;
  renew_token = true

  retry {
    attempts = 1
    backoff = &quot;250ms&quot;
  }
}

// log_level = &quot;debug&quot;

template {
  source      = &quot;certificate.tpl&quot;
  destination = &quot;client.crt&quot;
  command     = &quot;echo generate certificate!&quot;
}

template {
  source      = &quot;key.tpl&quot;
  destination = &quot;client.key&quot;
  command     = &quot;echo generate key!&quot;
}
</code></pre>
<h3 id="跑跑看吧"><a class="header" href="#跑跑看吧">跑跑看吧！</a></h3>
<pre><code class="language-bash=">$ consul-template -config=config.hcl
</code></pre>
<p>就會看到下列訊息反覆出現：</p>
<pre><code>generate certificate!
generate key!
expiration: revoked lease: lease_id=int-pki/issue/example-dot-com/..
</code></pre>
<p>拿到的 Certificate：</p>
<pre><code>Common Name: blah.example.com
Issuing Certificate: My Intermediate CA
Serial Number: 6C24455D423496C85411FF857EAC28127DF16B4D
Signature: sha256WithRSAEncryption
Valid From: 07:38:44 21 Jul 2021
Valid To: 07:40:14 21 Jul 2021
Key Usage: Digital Signature, Key Encipherment, Key Agreement
Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication
Subject Key Identifier: 77:79:22:4B:12:19:5D:F2:55:FF:76:11:CE:5D:34:1C:60:4C:44:76
Authority Key Identifier: keyid:46:C4:1E:F3:5B:EE:3D:64:88:37:CF:67:A8:E5:11:82:B5:CE:F0:18
Authority Info Access: CA Issuers - URI:http://localhost:8200/v1/int-pki/ca
Subject Alternative Names: DNS:blah.example.com
</code></pre>
<h2 id="clean-up"><a class="header" href="#clean-up">clean up</a></h2>
<p>若要清除過期的 cert，請呼叫</p>
<pre><code class="language-bash=">$ vault write root-pki/tidy tidy_revoked_certs=true
</code></pre>
<blockquote>
<p><a href="https://www.vaultproject.io/api-docs/secret/pki#tidy">相關說明</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="功能"><a class="header" href="#功能">功能</a></h1>
<p>讓 Vault 變成一台幫忙處理加解密的機器</p>
<ul>
<li>明文輸入，密文輸出。</li>
<li>密文輸入，透過密文的字首判斷是哪一個金鑰做的加密，輸出明文。</li>
<li>也可以純做簽、驗證。</li>
</ul>
<hr />
<h1 id="金鑰轉換"><a class="header" href="#金鑰轉換">金鑰轉換</a></h1>
<ul>
<li>會把該版本的金鑰所產生的密文加上該版本的標頭。
<ul>
<li>v1 key encryption result: <code>vault:v1:8SDd3WHDO...</code></li>
<li>v5 key encryption result: <code>vault:v5:bXkgc2Vjc...</code></li>
</ul>
</li>
<li>可以在透過參數 <code>min_decryption_version</code> 禁止使用過舊的金鑰。</li>
<li>若轉換過多金鑰會造成效率問題
<ul>
<li>可以產生全新的金鑰來避免過大的鑰匙版本</li>
<li><code>key1:v8:abc...</code> =&gt; post to <code>key1</code> with <code>vault:v8:abc...</code></li>
<li><code>key2:v6:def...</code> =&gt; post to <code>key2</code> with <code>vault:v6:def...</code></li>
</ul>
</li>
</ul>
<hr />
<h1 id="金鑰版本限制"><a class="header" href="#金鑰版本限制">金鑰版本限制</a></h1>
<ul>
<li><code>min_decryption_version</code>, <code>min_encryption_version</code>, <code>min_available_version</code>（刪除舊版本的金鑰）</li>
<li>如果要逐步淘汰舊版的金鑰呢？</li>
<li>rewrap - 把指定的密文解密並重新用新的金鑰加密
<ul>
<li><code>key_version</code> - 預設為最新版的金鑰</li>
<li><code>batch_input</code></li>
</ul>
</li>
</ul>
<hr />
<h1 id="特殊功能"><a class="header" href="#特殊功能">特殊功能</a></h1>
<h2 id="key-derivation"><a class="header" href="#key-derivation">Key derivation</a></h2>
<ul>
<li>加解密會需要 <code>content</code>（和 <code>salt</code> 一樣）。</li>
<li><code>new key = HMAC(key, content)</code></li>
<li>讓鑰匙在每次加密都不一樣，擁有更高的安全性。</li>
</ul>
<hr />
<h2 id="convergent-encryption"><a class="header" href="#convergent-encryption">Convergent encryption</a></h2>
<ul>
<li>確保當明文一樣，密文就會一樣。</li>
<li>用途之一：可以避免重複的資料存入 DB</li>
<li>必須配合使用 key derivation 保證安全性。</li>
<li>輸入明文外還要輸入 <code>nonce</code>。</li>
</ul>
<hr />
<h2 id="datakey-generation"><a class="header" href="#datakey-generation">Datakey generation</a></h2>
<ul>
<li>用途之一：加密大量資料，避免頻寬的佔用。</li>
<li>產生鑰匙。</li>
<li>利用加解密金鑰加密此鑰匙。
<ol>
<li>輸出加密後的鑰匙
<ul>
<li>重新要求解密得到真正的鑰匙</li>
</ul>
</li>
<li>直接輸出真正的鑰匙</li>
<li>預設：兩個都輸出</li>
</ol>
</li>
</ul>
<hr />
<h1 id="demo-1"><a class="header" href="#demo-1">DEMO</a></h1>
<h2 id="環境-1"><a class="header" href="#環境-1">環境</a></h2>
<pre><code class="language-bash=">$ vault secrets enable transit
# -f for force post request when no data
$ vault write -f transit/keys/example
$ vault policy write transit-example policy.hcl
$ vault token create \
  -field=token \
  -policy=transit-example \
  -ttl=1h
</code></pre>
<h2 id="加密"><a class="header" href="#加密">加密</a></h2>
<pre><code class="language-bash=">$ vault write -field=ciphertext \
  transit/encrypt/example \
  plaintext=$(base64 &lt;&lt;&lt; &quot;4111 1111 1111 1111&quot;)

vault:v1:+W+aOV4DqhOLqCmTZ2oRqj6qAjTyZNYkoYfUraPl88XwEy3hC8Ul2WyrcP8Mz/sg
</code></pre>
<h2 id="解密"><a class="header" href="#解密">解密</a></h2>
<pre><code class="language-bash=">$ vault write -field=plaintext \
  transit/decrypt/example \
  ciphertext='vault:v1:+W+aOV4DqhOLqCmTZ2oRqj6qAjTyZNYkoYfUraPl88XwEy3hC8Ul2WyrcP8Mz/sg'

NDExMSAxMTExIDExMTEgMTExMQo=
</code></pre>
<h2 id="金鑰轉換-1"><a class="header" href="#金鑰轉換-1">金鑰轉換</a></h2>
<pre><code class="language-bash=">$ vault write -f transit/keys/example/rotate
$ vault write -field=ciphertext \
  transit/encrypt/example \
  plaintext=$(base64 &lt;&lt;&lt; &quot;4111 1111 1111 1111&quot;)

vault:v2:Dbpgk1UhlY+74uj8ecmFEiYfriDTWZc907VgO1EWfSXmMnPW3j+qDaetDlnOTVOI
</code></pre>
<h2 id="金鑰限制"><a class="header" href="#金鑰限制">金鑰限制</a></h2>
<pre><code class="language-bash=">$ vault write transit/keys/example/config \
  min_decryption_version=2 \
  min_encryption_version=2

# Decrypt v1 will return error
$ vault write transit/decrypt/example \
  ciphertext='vault:v1:+W+aOV4DqhOLqCmTZ2oRqj6qAjTyZNYkoYfUraPl88XwEy3hC8Ul2WyrcP8Mz/sg'
</code></pre>
<h2 id="重包密文"><a class="header" href="#重包密文">重包密文</a></h2>
<pre><code class="language-bash=">$ vault write transit/keys/example/config min_decryption_version=1
$ vault write -field=ciphertext \
  transit/rewrap/example \
  ciphertext='vault:v1:+W+aOV4DqhOLqCmTZ2oRqj6qAjTyZNYkoYfUraPl88XwEy3hC8Ul2WyrcP8Mz/sg'
</code></pre>
<h2 id="永久刪除舊版金鑰"><a class="header" href="#永久刪除舊版金鑰">永久刪除舊版金鑰</a></h2>
<pre><code class="language-bash=">$ vault write transit/keys/example/config min_decryption_version=2
$ vault write transit/keys/example/trim min_available_version=2
</code></pre>
<h1 id="金鑰可以容忍的最大版本數量"><a class="header" href="#金鑰可以容忍的最大版本數量">金鑰可以容忍的最大版本數量</a></h1>
<table><thead><tr><th>金鑰種類</th><th>Consul 預設值 (512 KiB)</th></tr></thead><tbody>
<tr><td>aes128-gcm96 keys</td><td>2008</td></tr>
<tr><td>aes256-gcm96 keys</td><td>1865</td></tr>
<tr><td>chacha-poly1305 keys</td><td>1865</td></tr>
<tr><td>ed25519 keys</td><td>1420</td></tr>
<tr><td>ecdsa-p256 keys</td><td>817</td></tr>
<tr><td>ecdsa-p384 keys</td><td>659</td></tr>
<tr><td>ecdsa-p523 keys</td><td>539</td></tr>
<tr><td>1024-bit RSA keys</td><td>169</td></tr>
<tr><td>2048-bit RSA keys</td><td>116</td></tr>
<tr><td>4096-bit RSA kyes</td><td>89</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>介紹一些網路安全相關的東西</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="essay/web-security/url-structure.html">What is Origin?</a></p>
<h2 id="歷史"><a class="header" href="#歷史">歷史</a></h2>
<p>為了保護使用者的隱私和被要求的網站隱私。</p>
<h2 id="圖表說明"><a class="header" href="#圖表說明">圖表說明</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
    participant example.com
    participant browser
    participant image.com
    example.com-&gt;&gt;browser: 1. 給我看看圖片！
    browser-&gt;&gt;image.com: 2. HTTP Request&lt;br&gt;Origin: http://example.com
    image.com-&gt;&gt;browser: 3.1 HTTP Response（成功）&lt;br&gt;Access-Control-Allow-Origin: http://example.com
    image.com--&gt;&gt;browser: 3.1 HTTP Response（失敗）&lt;br&gt;Access-Control-Allow-Origin: http://other.com
</code></pre>
<ol>
<li>使用者進到 <code>http://example.com</code> 的網站。</li>
<li>使用者的瀏覽器透過網站需求可能會去跟其他網站（<code>http://image.com</code>）要檔案（圖片，CSS 檔...）。</li>
<li>為了保護被要求的網站隱私，若該網站回傳的標頭不允許該存取，瀏覽器會判定要求失敗，反之則成功。</li>
</ol>
<h2 id="access-control-allow-origin"><a class="header" href="#access-control-allow-origin">Access-Control-Allow-Origin</a></h2>
<ul>
<li><code>http://example.com</code></li>
<li><code>http://example.com | http://other.com</code></li>
<li><code>*</code></li>
</ul>
<h2 id="細節"><a class="header" href="#細節">細節</a></h2>
<ol>
<li>若 HTTP request <a href="essay/web-security/SimpleRequest">夾雜了些東西</a>，HTTP response 就會<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS#Access-Control-Expose-Headers">需要更多標頭來表達意願</a>。</li>
<li>若 HTTP request <a href="essay/web-security/SimpleRequest">夾雜了些東西</a>，瀏覽器可能還需要做<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS#%E9%A0%90%E6%AA%A2%E8%AB%8B%E6%B1%82">預先檢查</a>，若檢查失敗，不會做進一步的要求。</li>
</ol>
<blockquote>
<p>夾雜的東西常常就是使用者的隱私。</p>
</blockquote>
<h2 id="攻擊"><a class="header" href="#攻擊">攻擊</a></h2>
<p>若允許所有的要求，攻擊者可以在自己網站（<code>devil.com</code>）要求一個在被攻擊網站（<code>example.com</code>）中的會員專屬圖片，並透過圖片或其他互動方式要到會員個人可辨識的資料或甚至 <code>cookie</code> 的值。</p>
<h2 id="延伸"><a class="header" href="#延伸">延伸</a></h2>
<p><strong>very new feature!!</strong></p>
<ol>
<li><a href="https://wicg.github.io/cross-origin-embedder-policy/">Cross Origin Embedder Policy (COEP)</a>
<ul>
<li>網站是否需要使用 <code>CORP</code> 和 <code>CORS</code></li>
</ul>
</li>
<li><a href="https://github.com/whatwg/html/pull/5334/files">Cross Origin Opener Policy (COOP)</a>
<ul>
<li>能否在不移動網址情況下打開其他網頁（popup）</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)">Cross Origin Resource Policy (CORP)</a>
<ul>
<li><code>Cross-Origin-Resource-Policy</code>
<ul>
<li><code>same-origin</code></li>
<li><code>same-site</code></li>
<li><code>cross-origin</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.chromium.org/Home/chromium-security/corb-for-developers">Cross Origin Read Blocking (CORB)</a>
<ul>
<li><code>Cross-Origin-Embedder-Policy</code>
<ul>
<li><code>require-corp</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什麼是-mixed-content"><a class="header" href="#什麼是-mixed-content">什麼是 Mixed Content</a></h1>
<ul>
<li>同一個網站擁有多個網站的資源
<ul>
<li>JS</li>
<li>CSS</li>
<li>圖片等等</li>
</ul>
</li>
<li>影響網站行為</li>
<li>&lt;a href=“http://evil.com”&gt; 不是！</li>
</ul>
<hr />
<h1 id="哪些需要注意"><a class="header" href="#哪些需要注意">哪些需要注意</a></h1>
<ul>
<li>除了影片、聲音、圖像都應該要擋</li>
<li>圖像也要注意 把垃圾桶的圖標和儲存起來的圖標交換</li>
<li>舊的瀏覽器可能防護不夠
<ul>
<li>IE8 以下</li>
</ul>
</li>
</ul>
<hr />
<h1 id="防護"><a class="header" href="#防護">防護</a></h1>
<ul>
<li>http:// =&gt; https://</li>
<li>從本地端送資料而不是從別的網站要</li>
<li>Header: Content Security Policy
<ul>
<li>upgrade-insecure-requests
<ul>
<li>cascades into &lt;iframe&gt;</li>
</ul>
</li>
<li>blocking resources</li>
</ul>
</li>
<li>掃描工具：
<ul>
<li><a href="https://httpschecker.net/how-it-works#httpsChecker">HTTPSChecker</a></li>
<li><a href="https://github.com/bramus/mixed-content-scan">Mixed Content Scan</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="essay/web-security/owasp-api-top10.html#broken-object-level-authorization">Broken Object Level Authorization</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#broken-authentication">Broken Authentication</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#excessive-data-exposure">Excessive Data Exposure</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#lack-of-resources--rate-limiting">Lack of Resources &amp; Rate Limiting</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#broken-function-level-authorization">Broken Function Level Authorization</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#mass-assignment">Mass Assignment</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#security-misconfiguration">Security Misconfiguration</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#injection">Injection</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#improper-assets-management">Improper Assets Management</a></li>
<li><a href="essay/web-security/owasp-api-top10.html#insufficient-logging--monitoring">Insufficient Logging &amp; Monitoring</a></li>
</ul>
<h2 id="broken-object-level-authorization"><a class="header" href="#broken-object-level-authorization">Broken Object Level Authorization</a></h2>
<pre><code>GET /api/v2/shops/{shop_name}/revenue_data.json HTTP/1.1
...
</code></pre>
<p>攻擊者只要更改 <code>shop_name</code> 就可以存取他人的資料。</p>
<hr />
<h2 id="broken-authentication"><a class="header" href="#broken-authentication">Broken Authentication</a></h2>
<p>如果 API 在處理身份認證時，沒有適當保護，如：<code>CAPTCHA</code>、<code>速度限制</code>、<code>鎖 IP</code> 等。</p>
<p>攻擊者可以運用使用者帳號、密碼組合列表反覆嘗試來取得權限， 就可以得到正確的組合。</p>
<hr />
<h2 id="excessive-data-exposure"><a class="header" href="#excessive-data-exposure">Excessive Data Exposure</a></h2>
<p>新進<code>保全</code>只能存取限制的<code>監控</code>。</p>
<pre><code>GET /api/v2/camera/ids HTTP/1.1
...
</code></pre>
<p>回傳的卻是全部的<code>監控</code>，然後再在 APP 作過濾和限制。</p>
<hr />
<h2 id="lack-of-resources--rate-limiting"><a class="header" href="#lack-of-resources--rate-limiting">Lack of Resources &amp; Rate Limiting</a></h2>
<p>阻斷服務攻擊 (DoS)</p>
<pre><code>GET /api/v2/users?page=1&amp;size=100 HTTP/1.1
...
</code></pre>
<p><code>size</code> 從 <code>100</code> 調整成 <code>2,000,000</code>。</p>
<hr />
<h2 id="broken-function-level-authorization"><a class="header" href="#broken-function-level-authorization">Broken Function Level Authorization</a></h2>
<p>可以存取未經授權的功能</p>
<pre><code>POST /api/admin/v2/invites HTTP/1.1

...

{&quot;email&quot;：&quot;hugo@malicious.com&quot;}
</code></pre>
<p>注意和 <a href="essay/web-security/owasp-api-top10.html#Broken-Object-Level-Authorization">Object</a> 之間的差異</p>
<hr />
<h2 id="mass-assignment"><a class="header" href="#mass-assignment">Mass Assignment</a></h2>
<p>比較下列兩段程式碼的差異。</p>
<pre><code class="language-javascript=">const user = new User(req.body);
user.update();
</code></pre>
<pre><code class="language-javascript=">const data = req.body;
const user = new User({ name: data.name, age: data.age });
user.update();
</code></pre>
<hr />
<p>若使用者打入以下 API 尚無影響。</p>
<pre><code>PUT /api/v2/user/data HTTP/1.1

...

{&quot;name&quot;：&quot;john&quot;,&quot;age&quot;：24}
</code></pre>
<p>但改成以下資訊，則會給予錯誤權限。</p>
<pre><code>PUT /api/v2/user/data HTTP/1.1

...

{&quot;name&quot;：&quot;john&quot;,&quot;age&quot;：24,&quot;money&quot;：999999}
</code></pre>
<hr />
<h2 id="security-misconfiguration"><a class="header" href="#security-misconfiguration">Security Misconfiguration</a></h2>
<p>如果資料庫管理系統使用的是預設配置</p>
<p>而其在默認情況下會解除身份認證...</p>
<hr />
<h2 id="injection"><a class="header" href="#injection">Injection</a></h2>
<pre><code>POST /api/v2/auth/login HTTP/1.1

...

{&quot;account&quot;：&quot;some-account' OR 1 --&quot;, &quot;password&quot;: &quot;dont-care&quot;}
</code></pre>
<p>在資料庫中會如以下執行：</p>
<pre><code class="language-sql=">SELECT * FROM user
WHERE account='some-account' OR 1 --' AND password='dont-care'
LIMIT 1
</code></pre>
<hr />
<h2 id="improper-assets-management"><a class="header" href="#improper-assets-management">Improper Assets Management</a></h2>
<p><code>v2</code> 把 <a href="essay/web-security/owasp-api-top10.html#Lack-of-Resources-amp-Rate-Limiting">Lack of Resources &amp; Rate Limiting</a> 的問題修好了</p>
<pre><code>GET /api/v2/users?page=1&amp;size=100 HTTP/1.1
...
</code></pre>
<p>但是 <code>v1</code> 呢？有正確修正或重新導入（redirect）到 <code>v2</code> 嗎</p>
<p>測試環境的 DB 有沒有和正式環境互相影響？</p>
<hr />
<h2 id="insufficient-logging--monitoring"><a class="header" href="#insufficient-logging--monitoring">Insufficient Logging &amp; Monitoring</a></h2>
<p>好的 Log 和警告系統，會讓管理員有能力當下對攻擊做處理。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="passsword"><a class="header" href="#passsword">Passsword</a></h2>
<p>Referer: https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#testing-best-practices-for-passwords-mstg-auth-5-and-mstg-auth-6</p>
<ul>
<li><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md#implement-proper-password-strength-controls">架構的檢查</a></li>
<li>檢查密碼強度，<a href="https://github.com/dropbox/zxcvbn">zxcvbn</a></li>
<li>檢查密碼被破解過，<a href="https://haveibeenpwned.com/">Have I been pwned?</a></li>
<li>限制嘗試</li>
<li>自己攻擊看看，<a href="https://portswigger.net/burp/help/intruder_using.html">Burp Suite Intruder</a></li>
</ul>
<h2 id="session"><a class="header" href="#session">Session</a></h2>
<p>Referer: https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#session-management-best-practices</p>
<ul>
<li>每次需要驗證身份時要做檢查</li>
<li>要過期</li>
<li>根據不同 Framework 有不同 best practice，請詳閱！！</li>
</ul>
<h2 id="2fa"><a class="header" href="#2fa">2FA</a></h2>
<ul>
<li>SMS-OTP
<ul>
<li>NIST: &quot;Due to the risk that SMS messages may be intercepted or redirected, implementers of new systems SHOULD carefully consider alternative authenticators.&quot;</li>
<li>可能遭遇的威脅和預防方式：https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#dangers-of-sms-otp</li>
</ul>
</li>
<li>Transaction Signing with Push Notifications and PKI
<ul>
<li>手機建立公私鑰</li>
<li>公鑰送給後端</li>
<li>若需要驗證的行為：
<ul>
<li>發通知（Push notifications）到手機</li>
<li>使用者授權</li>
<li>傳送私鑰簽核過的訊息</li>
<li>驗證</li>
</ul>
</li>
<li>詳細注意事項和測試：https://github.com/OWASP/owasp-mstg/blob/master/Document/0x04e-Testing-Authentication-and-Session-Management.md#transaction-signing-with-push-notifications-and-pki</li>
</ul>
</li>
</ul>
<h2 id="jwt"><a class="header" href="#jwt">JWT</a></h2>
<ul>
<li>每次都要驗證</li>
<li>鑰匙藏好</li>
<li>藏好機敏資料，若有必要請加密</li>
<li>使用 <code>jti</code>（JWT ID）</li>
<li>token 請放在 <code>KeyChain</code> 或 <code>KeyStore</code></li>
<li>Header 不能讓 <code>alg</code> 可接受 <code>none</code></li>
<li><code>exp</code> 要注意</li>
</ul>
<h2 id="oauth-20"><a class="header" href="#oauth-20">OAuth 2.0</a></h2>
<ul>
<li>別用 <code>implicit grant</code>，<code>code grant</code> 要一次性且短時</li>
<li>PKCE</li>
<li>Access Token 若存在不信任的地方要短暫的期限</li>
<li>有限制的 <code>scope</code></li>
<li>除了 access token 要有可以驗證使用者的資訊</li>
<li><a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps-12">OAuth 2.0 for Native APP</a></li>
</ul>
<h2 id="怎麼確認這是同一台手機"><a class="header" href="#怎麼確認這是同一台手機">怎麼確認這是同一台手機</a></h2>
<p>如論何種狀況，你都應該驗證請求是否來自不同裝置。因此，要能確認你的程式真的被裝在正確的裝置上。</p>
<p>iOS：</p>
<blockquote>
<p>In iOS, a developer can use <code>identifierForVendor</code>, which is related to the bundle ID: the moment you change a bundle ID, the method will return a different value. When the app is ran for the first time, make sure you store the value returned by <code>identifierForVendor</code> to the KeyChain, so that changes to it can be detected at an early stage.</p>
</blockquote>
<p>Android：</p>
<blockquote>
<p>In Android, the developer can use <code>Settings.Secure.ANDROID_ID</code> till Android 8.0 (API level 26) to identify an application instance. Note that starting at Android 8.0 (API level 26), <code>ANDROID_ID</code> is no longer a device unique ID. Instead, it becomes scoped by the combination of app signing key, user and device. So validating <code>ANDROID_ID</code> for device blocking could be tricky for these Android versions. Because if an app changes its signing key, the <code>ANDROID_ID</code> will change and it won't be able to recognize old users devices. Therefore, it's better to store the <code>ANDROID_ID</code>encrypted and privately in a private a shared preferences file using a randomly generated key from the <code>AndroidKeyStore</code> and preferably AES_GCM encryption. The moment the app signature changes, the application can check for a delta and register the new <code>ANDROID_ID</code>. The moment this new ID changes without a new application signing key, it should indicate that something else is wrong.</p>
</blockquote>
<p>除此之外，在一開始的裝置綁定上，可以透過簽發請求，來提高安全性。</p>
<blockquote>
<p>Next, the device binding can be extended by signing requests with a key stored in the <code>Keychain</code> for iOS and in the <code>KeyStore</code> in Android can reassure strong device binding.</p>
</blockquote>
<p>你也可以驗證 <code>IP</code>、<code>地理位置</code>和<code>時間軌跡</code>。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<ul>
<li>讓使用者知道 {} 也登入帳號了
<ul>
<li>哪個裝置</li>
<li>哪個時間</li>
<li>哪個地點</li>
</ul>
</li>
<li>要通知使用者有新的登入</li>
<li>讓使用者知道最後行為是什麼</li>
<li>每次登入、登出要做紀錄</li>
<li>這些是機敏的行為
<ul>
<li>登入</li>
<li>改密碼</li>
<li>個資改變 (name, email address, telephone number, etc.)</li>
<li>敏感行為 (purchase, accessing important resources, etc.)</li>
<li>同意條款</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E9%96%93%E7%9A%84%E9%8C%AF%E8%AA%A4%E5%AF%A6%E4%BD%9Cimproper-platform-usage">不同平台間的錯誤實作（Improper Platform Usage）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E8%B3%87%E6%96%99%E5%84%B2%E5%AD%98insecure-data-storage">不安全的資料儲存（Insecure Data Storage）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%82%B3%E8%BC%B8%E5%B1%A4%E4%BF%9D%E8%AD%B7%E4%B8%8D%E8%B6%B3insecure-communication">傳輸層保護不足（Insecure Communication）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%A9%97%E8%AD%89%E6%A9%9F%E5%88%B6insecure-authentication">不安全的驗證機制（Insecure Authentication）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E9%8C%AF%E8%AA%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A2%BC%E5%AD%B8broken-cryptography">錯誤的使用密碼學(Broken Cryptography)</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%8E%88%E6%AC%8A%E6%A9%9F%E5%88%B6insecure-authorization">不安全的授權機制（Insecure Authorization）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%BD%A0%E7%9A%84-app-%E5%AF%AB%E5%BE%97%E4%B8%8D%E5%A5%BDpoor-code-quality">你的 APP 寫得不好（Poor Code Quality）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A2%AB%E6%94%BE%E5%88%B0%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%92%B0%E5%A2%83%E4%BA%86code-tampering">你的程式碼被放到非正常環境了（Code Tampering）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8Breverse-engineering">逆向工程（Reverse Engineering）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%8F%AF%E5%BD%B1%E9%9F%BF%E7%A8%8B%E5%BC%8F%E9%81%8B%E8%A1%8C%E7%9A%84%E6%A9%9F%E5%88%B6extraneous-functionality">可影響程式運行的機制（Extraneous Functionality）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E8%88%8A%E7%9A%84">舊的</a>
<ul>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%BC%BA%E6%9C%8D%E5%99%A8%E7%AB%AF%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%E8%84%86%E5%BC%B1weak-server-side-controls">伺服器端安全控制脆弱（Weak Server Side Controls）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E9%9D%9E%E6%95%85%E6%84%8F%E6%88%96%E6%84%8F%E5%A4%96%E9%80%A0%E6%88%90%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%96%E6%B4%A9unintended-data-leakage">非故意或意外造成的資料外洩（Unintended Data Leakage）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%AE%A2%E6%88%B6%E7%AB%AF%E6%B3%A8%E5%85%A5client-side-injection">客戶端注入(Client Side Injection)</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E4%B8%8D%E9%81%A9%E7%95%B6%E7%9A%84-session-%E8%99%95%E7%90%86improper-session-handling">不適當的 Session 處理（Improper Session Handling）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%AE%89%E5%85%A8%E6%B1%BA%E7%AD%96%E6%98%AF%E7%B6%93%E7%94%B1%E4%B8%8D%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%BC%B8%E5%85%A5security-decisions-via-untrusted-inputs">安全決策是經由不受信任的輸入（Security Decisions Via Untrusted Inputs）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%B0%81%E8%A3%9D%E6%AA%94%E6%A1%88%E4%BF%9D%E8%AD%B7%E4%B8%8D%E8%B6%B3--%E7%BC%BA%E5%B0%91%E4%BA%8C%E9%80%B2%E4%BD%8D%E4%BF%9D%E8%AD%B7lack-of-binary-protections">封裝檔案保護不足 / 缺少二進位保護（Lack of Binary Protections）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E5%81%B4%E9%80%9A%E9%81%93%E8%B3%87%E6%96%99%E6%B4%A9%E6%BC%8Fside-channel-data-leakage">側通道資料洩漏（Side Channel Data Leakage）</a></li>
<li><a href="essay/web-security/owasp-mobile-risk-top10.html#%E6%95%8F%E6%84%9F%E8%B3%87%E8%A8%8A%E6%B4%A9%E6%BC%8Fsensitive-informaiton-disclosure">敏感資訊洩漏（Sensitive Informaiton Disclosure）</a></li>
</ul>
</li>
</ul>
<h2 id="不同平台間的錯誤實作improper-platform-usage"><a class="header" href="#不同平台間的錯誤實作improper-platform-usage">不同平台間的錯誤實作（Improper Platform Usage）</a></h2>
<p>例如把機敏資料存進 local storage 而不是原生的加密儲存空間：</p>
<ul>
<li>iOS 的 <code>Keychain</code></li>
<li>Android 的 <code>Keystore</code></li>
</ul>
<p>請參照各平台的最佳做法！！</p>
<h2 id="不安全的資料儲存insecure-data-storage"><a class="header" href="#不安全的資料儲存insecure-data-storage">不安全的資料儲存（Insecure Data Storage）</a></h2>
<p>可能的儲存空間：</p>
<ul>
<li>Log</li>
<li>SD card</li>
<li>Cloud synced</li>
<li>OS</li>
<li>Frameworkd（框架如：Flutter）</li>
<li>Binary data（程式碼裡面）</li>
</ul>
<p>預防：</p>
<ul>
<li>只儲存必要資訊</li>
<li>將敏感檔案加密，和選擇好儲存的位置</li>
</ul>
<p><a href="https://github.com/OWASP/igoat">iGoat</a>的<a href="https://youtu.be/U3wabqTTXSE?t=589">教學影片</a>。</p>
<h2 id="傳輸層保護不足insecure-communication"><a class="header" href="#傳輸層保護不足insecure-communication">傳輸層保護不足（Insecure Communication）</a></h2>
<p>傳輸媒介可包含：</p>
<ul>
<li>網路連線</li>
<li>Wifi 連線</li>
<li>近場通訊（Near Field Communication，NFC）連線</li>
<li>...</li>
</ul>
<p>最佳做法：</p>
<ul>
<li>確保所有敏感性資料有採用加密方式（TLS、SSL）進行傳輸
<ul>
<li>並實踐其最佳做法</li>
</ul>
</li>
<li>持續注意網路流量</li>
<li>不要把機敏資料透過 <code>SMS</code>、<code>MMS</code> 傳出去</li>
</ul>
<h2 id="不安全的驗證機制insecure-authentication"><a class="header" href="#不安全的驗證機制insecure-authentication">不安全的驗證機制（Insecure Authentication）</a></h2>
<ul>
<li>把 Session 或 Token 儲存進安全位置</li>
<li>別用 PIN 碼驗證</li>
<li>若您的 App 無須 <strong>離線存取</strong>，請停用此功能</li>
<li>若您的應用程式需維持機密性，請進行 <strong>雙因素身分驗證</strong></li>
<li>善用如 Microsoft / Google Authenticator 等服務</li>
</ul>
<h2 id="錯誤的使用密碼學broken-cryptography"><a class="header" href="#錯誤的使用密碼學broken-cryptography">錯誤的使用密碼學(Broken Cryptography)</a></h2>
<ul>
<li>保護好你的鑰匙</li>
<li>別自己設計密碼學相關的演算法</li>
<li>不安全或過時的演算法（不單指加密）
<ul>
<li>RC2</li>
<li>MD4</li>
<li>MD5</li>
<li>SHA1</li>
</ul>
</li>
</ul>
<h2 id="不安全的授權機制insecure-authorization"><a class="header" href="#不安全的授權機制insecure-authorization">不安全的授權機制（Insecure Authorization）</a></h2>
<pre><code>GET /api/some-method?rule=user HTTP/1.1
</code></pre>
<p>可以輕易改成 <code>rule=admin</code></p>
<p>請用 Server 端的資料來授權使用者</p>
<h2 id="你的-app-寫得不好poor-code-quality"><a class="header" href="#你的-app-寫得不好poor-code-quality">你的 APP 寫得不好（Poor Code Quality）</a></h2>
<p>泛指所有在 Client 端的發生的問題</p>
<ul>
<li>buffer overflow</li>
<li>format string vulnerabilities</li>
<li>...</li>
</ul>
<p>預防：</p>
<ul>
<li>讓多人一起檢查程式碼</li>
<li>寫好看的程式碼，好看的程式碼幫助 Debug</li>
<li><code>buffer overflow</code> 和 <code>memory leak</code> 是高風險的安全性問題</li>
</ul>
<pre><code class="language-c">include &lt;stdio.h&gt;

 int main(int argc, char **argv)
 {
    char buf[8]; // buffer for eight characters
    gets(buf); // 使用者輸入，這很危險！
    printf(&quot;%s\n&quot;, buf); // print out data stored in buf
    return 0; // 0 as return value
 }
</code></pre>
<h2 id="你的程式碼被放到非正常環境了code-tampering"><a class="header" href="#你的程式碼被放到非正常環境了code-tampering">你的程式碼被放到非正常環境了（Code Tampering）</a></h2>
<p>一般來說，所有 APP 都會有這問題
但是如果 APP 大部分邏輯都在驗證後或 Server 端的輸出，則此類安全性議題可忽略</p>
<blockquote>
<p>較需要注意的產業：手遊、工具程式</p>
</blockquote>
<p>需參照各平台的最佳作法來預防。</p>
<h2 id="逆向工程reverse-engineering"><a class="header" href="#逆向工程reverse-engineering">逆向工程（Reverse Engineering）</a></h2>
<p>有工具可預防（IDA Pro、Hopper），也有很多工具可幫助逆向工程，挑一下</p>
<blockquote>
<p>減少一個 Function 的工作，讓逆向後的程式碼不容易閱讀</p>
</blockquote>
<h2 id="可影響程式運行的機制extraneous-functionality"><a class="header" href="#可影響程式運行的機制extraneous-functionality">可影響程式運行的機制（Extraneous Functionality）</a></h2>
<p>攻擊者可以把 APP 執行在 local 端，然後改設定檔或觀察 log。</p>
<ul>
<li>最終的程式碼不能有 <code>debug</code> 的 log</li>
<li>避免若 config 檔變化了，產品的機敏資訊或特殊環境仍能運行或暴露
<ul>
<li>單元或整合測試不要在最終產品中</li>
<li>不能有 UAT、staging、demo 或 test 環境的程式碼在最終產品</li>
</ul>
</li>
</ul>
<h2 id="舊的"><a class="header" href="#舊的">舊的</a></h2>
<h3 id="伺服器端安全控制脆弱weak-server-side-controls"><a class="header" href="#伺服器端安全控制脆弱weak-server-side-controls">伺服器端安全控制脆弱（Weak Server Side Controls）</a></h3>
<p>後端需要注意可能遭受的攻擊：</p>
<ul>
<li><a href="essay/web-security//ZR-UNvOeRjCGIRVNJMVXpw">OWASP Top 10</a></li>
<li><a href="essay/web-security//C_BB9B5fQwyODuOZbfCmXg">OWASP API Top 10</a></li>
</ul>
<p>基本觀念：</p>
<ul>
<li>絕不相信用戶端</li>
<li>謹慎設計行動裝置的伺服器端控制</li>
<li>絕不使用用戶端應用程式執行存取控制</li>
</ul>
<h3 id="非故意或意外造成的資料外洩unintended-data-leakage"><a class="header" href="#非故意或意外造成的資料外洩unintended-data-leakage">非故意或意外造成的資料外洩（Unintended Data Leakage）</a></h3>
<ul>
<li>將裝置可收集的資料限制在其所需的範圍</li>
<li>切勿將敏感資料儲存於公共場所</li>
<li>瞭解並密切監控您的應用程式處理，如：剪下 - 貼上、應用程式背景處理、Cookie、 URL 快取及鍵盤按下快取等動作</li>
</ul>
<h3 id="客戶端注入client-side-injection"><a class="header" href="#客戶端注入client-side-injection">客戶端注入(Client Side Injection)</a></h3>
<ul>
<li>使用白名單方法是抵擋 XSS</li>
<li>確保使用者資料通過參數化的查詢</li>
<li>驗證並編碼所有儲存在裝置上的資料</li>
</ul>
<p>使用嚴謹的身分驗證與授權（例如：雙因素認證）</p>
<h3 id="不適當的-session-處理improper-session-handling"><a class="header" href="#不適當的-session-處理improper-session-handling">不適當的 Session 處理（Improper Session Handling）</a></h3>
<ul>
<li>避免使用裝置的硬體識別碼來當作 Session 值</li>
<li>Session 值的過期時間應設定在一個可接受範圍內</li>
<li>應有能夠快速撤銷 Token 的機制</li>
</ul>
<h3 id="安全決策是經由不受信任的輸入security-decisions-via-untrusted-inputs"><a class="header" href="#安全決策是經由不受信任的輸入security-decisions-via-untrusted-inputs">安全決策是經由不受信任的輸入（Security Decisions Via Untrusted Inputs）</a></h3>
<p>假設 Skype 應用程式具有 <code>HTML</code> 或 <code>Script Injection</code> 弱點，攻擊者只要事先把具有惡意連結的 <code>iframe</code> 寫入某個特定網頁：</p>
<pre><code>&lt;iframe src=&quot;skype:17031234567?call&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>一但可攜式行動裝置的瀏覽器讀取到此 <code>iframe</code> 程式碼時，Skype 應用程式將無需使用者授權，自動開始播號給指定的電話號碼。</p>
<p><strong>Cross Site Rrequest Foriegn</strong></p>
<h3 id="封裝檔案保護不足--缺少二進位保護lack-of-binary-protections"><a class="header" href="#封裝檔案保護不足--缺少二進位保護lack-of-binary-protections">封裝檔案保護不足 / 缺少二進位保護（Lack of Binary Protections）</a></h3>
<p>Binary 保護可確保攻擊者無法透過逆向工程獲得您的 App</p>
<ul>
<li>切勿將程式碼儲存在不受您控制的不安全環境下</li>
<li>確保正確使用憑證綁定及偵錯工具偵測控制</li>
<li>監控執行階段程式碼是否在 App 活動中出現異常</li>
</ul>
<h3 id="側通道資料洩漏side-channel-data-leakage"><a class="header" href="#側通道資料洩漏side-channel-data-leakage">側通道資料洩漏（Side Channel Data Leakage）</a></h3>
<p>資料應避免自動儲存於可攜式行動裝置內</p>
<ul>
<li>網頁暫存（Web Cache）</li>
<li>按鍵側錄（Keystorke Logging）</li>
<li>擷取畫面（Screenshots）</li>
<li>日誌檔（Logs）</li>
<li>暫存目錄（Temp Directories）</li>
</ul>
<h3 id="敏感資訊洩漏sensitive-informaiton-disclosure"><a class="header" href="#敏感資訊洩漏sensitive-informaiton-disclosure">敏感資訊洩漏（Sensitive Informaiton Disclosure）</a></h3>
<p>應用程式原始碼中，把輸入或輸出的相關參數直接寫入在程式碼當中</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
                <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-P67FD9XP83', 'auto');
                ga('send', 'pageview');
            }
        </script>
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
