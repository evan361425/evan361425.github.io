---
tags: SRE-workbook
---

# 非抽象大型系統設計

非抽象大型系統設計（Non Abstract Large System Design, NALSD）的目的在於讓開發者設計系統架構時，
有個依據建立穩健而又高擴充的系統。

本文先透過定義問題，收集需求並反覆審視、循序改善架構的設計，最終得到一個可靠的系統設計解方。
目標是讓開發者能設計出一個在初期便擁有高穩健性且同時擁有未來調整的環境，
而這個過程，就是把抽象的需求，降成實際可被估量的實踐。
這些實踐包括：

- 容量（capacity）預估
- 功能獨立性（類似艙壁原則，bulkheads），避免單一功能的損壞影響全部的服務。
- 允許服務降能（degradation）

這些實踐讓 SRE 有能力在面對系統設計時，
思考系統的擴充性和可能的瓶頸，並專注在這些點上。
在接下來的練習中，每一次設計的迭代，都可以反覆問自己這四個問題：

- **這個設計可能嗎？**假設不去管資源議題，這個設計可以滿足需求嗎？
- **有沒有更好的方法？**可以讓他更快、更輕便、更有效率嗎？
- **這方法可以在有限的設備數量、時間和金錢內達成嗎？**
- **這個架構允許降能嗎？**當某組建壞掉會發生什麼事？當資料中心壞掉會發生什麼事？

!!! success "練習的目的"
    所有的系統最終都要實際跑在真實的資料中心和真實的設備上，
    我們需要反覆練習將白板上的架構圖，轉化成實際要使用的設備數量等等。
    聽起來很瑣碎，但是不去練習和規劃，當我們實際上線時，可能會付出更慘痛的代價。

    練習中的假設和推估會比最終實際結果重要。
    早期的假設會很大程度影響最終的成果，但是在 NALSD 中，
    我們並不是要練習出完美的假設，而是在多個**不完美但是合理的假設**中導出一個更好被詮釋的結果

## 練習流程

開始前，先簡述一下流程。
我們將使用反覆迭代的方式去設計系統，每次迭代都會定義出相關的設計並找出它的優勢和弱點。
而每次迭代的分析，都會幫助我們找出優點在下一次的迭代中設計出更好的系統。
在初始階段我們會根據以下兩個問題來設計系統：

- 這個設計可能嗎？
- 有沒有更好的方法？

接著我們會去思考針對**初始設計的擴充性**，這時就會再去回應以下三個問題：

- 這方法可以在有限的設備數量、時間和金錢內達成嗎？
- 這個架構允許降能嗎？
- 有沒有更好的方法？

雖然這裡列出順序，但實際練習時這些問題可能是反覆詰問的。
例如在初始階段，我們可能就會先考慮它的可擴充性。
如果這個設計在後面的問題無法得到好的回答，我們就會修正或替換某個組件，接著重頭開始。

## 練習：AdWords

AdWords 是 Google 一項產品，用來在使用者透過 Google 搜尋時，推出純文字的廣告。
這次練習，是要設計出一個系統，可以觀測並回報正確的 *click-through rate*
（CTR，*使用者點擊廣告次數* 除以 *廣告推播數*）。

對於使用者來說，會想要知道推播的廣告是因為哪些關鍵字被投放廣告以及哪些關鍵字讓廣告更容易被點擊，
也就是需要組合 *關鍵字對廣告投放率* 以及 *關鍵字對廣告點擊率*。

### 定義需求的 SLO

首先我們站在使用者的角度去思考，對我們來說最關心的是什麼？
假設最關心的是 **面板中的請求是否快速** 以及 **資料是否即時**，由此訂定出 SLO：

- 99.9% 的請求都要在 1 秒內完成；
- 99.9% 的 CTR 資訊都要顯示 5 分鐘內的資料。

### 評估需求的資源

系統中已經存在機制把使用者的每個 *搜尋* 和 *廣告點擊* 記錄下來，以下是這些日誌的內容：

| 名稱 | 變數名稱 | 型別 | 佔位（bytes）|
| - | - | - | - |
| 時間 | `time` | 64-bit integer | 8 |
| ID | `query_id` | 64-bit integer | 8 |
| ADs | `ad_ids` | array of 64-bit integers | 8~24（每次搜尋最多放 3 個廣告） |
| 關鍵字 | `search_terms` | array of char | ≈500 |
| 元資料 | `metadata` | array of char | 500~1000（使用語言、哪台機器服務的等等） |

> 搜尋的日誌內容

| 名稱 | 變數名稱 | 型別 | 佔位（bytes）|
| - | - | - | - |
| 時間 | `time` | 64-bit integer | 8 |
| ID | `query_id` | 64-bit integer | 8 |
| AD | `ad_id` | 64-bit integers | 8 |

> 廣告點擊的日誌內容

??? question "為什麼不把 search_term 放進廣告點擊的日誌"
    如果我們直接把 `search_term` 放進廣告點擊的日誌中，
    我們就可以直接透過該日誌找到我們想要的指標 *關鍵字對廣告點擊率*。

    但現實是這些點擊紀錄是透過 HTTP URL 傳遞，換句話說這個 URL 是有長度限制的，
    除此之外，Google 需要提供的指標不只是 CTR，為了資源使用率和資料一致性的考量，
    不會把 `search_term` 到處丟。

假設：

- 服務每秒會有 500k 的搜尋（Google search）和 10k 的廣告點擊；
- 搜尋每筆日誌大小為 2KB，這是高估，但是為了避免非預期大流量，高估是可被接受的；

LogJoiner

- source: 1.92 Mbps = 240KB/sec = (10^4 click/sec) * 24 bytes
- reqA: 640 Kbps = 80 KB/sec = (10^4 click/sec) * (8 bytes, query_id)
- resA: 160Mbps = 20MB/sec = (10^4 click/sec) * (2KB, query log)

QueryStore

- disk: 100TB/day = 50k rps *86.4k sec/day* 2KB
- reqA
- resA

LogJoiner

- reqB: 80Mbps = (10^4 click/sec) * (~1KB, ad_id+search_term+query_id)

ClickMap

- reqB
- Disk: 14GB/day = 10k clieck/sec *86.4 sec/day* (16 bytes, time+query_id)

QueryMap

- Disk: 2TB/day = 50k rps *86.4 sec/day* 16 bytes * (3, no. of ad each query)

### 設計可行架構

### 延伸架構去滿足 SLO

## 總結

NALSD 是一個設計系統時反覆迭代的過程，首先把架構拆成對應的邏輯元件，並想像其置入線上環境的資源需求。
在這之中 SLO 的訂定變得尤為重要，因為 SLO 會驅動架構設計的進化，並在設計過程中不會迷航。

之所以說反覆迭代，就是在設計過程中每一次結束都要反覆問自己還能更好嗎？
讓設計者除了能依據 SLO 這個準繩之外，還能透過前一次的架構或前幾次的架構，最終產出更好的架構。

根據 Google 的經驗，**把抽象的需求轉化成實際的資源**，
例如 CPU、記憶體、Network throughput 等等，
對於架構最終的穩定性非常重要。
